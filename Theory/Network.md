# 计算机网络



   * [网络分层模型](#网络分层模型)
      * [OSI 七层模型和 TCP/IP 四层模型](#osi-七层模型和-tcpip-四层模型)
      * [意义](#意义)
   * [HTTP](#http)
      * [定义](#定义)
      * [HTTP 报文](#http-报文)
      * [TLS](#tls)
      * [HTTP vs HTTPS](#http-vs-https)
      * [HTTP/1.0 vs HTTP/1.1](#http10-vs-http11)
      * [HTTP vs WebSocket vs SSE](#http-vs-websocket-vs-sse)
      * [Cookie](#cookie)
      * [CORS](#cors)
   * [DNS](#dns)
      * [定义](#定义)
      * [DNS 服务器的类型和处理过程](#dns-服务器的类型和处理过程)
      * [DNS 记录](#dns-记录)
      * [DNS 劫持](#dns-劫持)
   * [TCP](#tcp)
      * [传输区分](#传输区分)
      * [UDP 区别](#udp-区别)
      * [三次握手](#三次握手)
      * [四次挥手](#四次挥手)
      * [编号变化](#编号变化)
      * [可靠性](#可靠性)
      * [拥塞控制算法](#拥塞控制算法)
   * [IP](#ip)
      * [定义](#定义)
      * [IP 地址](#ip-地址)
      * [获取真实 IP](#获取真实-ip)
      * [特殊 IP 地址](#特殊-ip-地址)
   * [NAT](#nat)
      * [定义](#定义)
      * [类别](#类别)
      * [意义](#意义)
   * [ARP](#arp)
      * [MAC 地址](#mac-地址)
      * [网卡](#网卡)
      * [ARP 表](#arp-表)
      * [工作流程](#工作流程)
      * [ARP 请求](#arp-请求)
   * [网关 Gateway](#网关-gateway)
      * [定义](#定义)
      * [路由协议](#路由协议)
   * [访问 URL 全过程](#访问-url-全过程)



## 网络分层模型

### OSI 七层模型和 TCP/IP 四层模型

1. 应用层 Application：负责为用户程序提供网络服务
2. 表示层 Presentation：负责将网络传输的数据进行格式化、压缩、加/解密、编/解码
3. 会话层 Session：负责管理（创建、维护、终止）应用之间会话
4. 传输层 Transport：负责为进程提供端到端的可靠/不可靠传输
5. 网络层 Network：负责路由选择和逻辑寻址，实现端到端的数据包传输
6. 链路层 Data Link：负责差错检测、流量控制，在物理层上提供可靠的数据帧传输
7. 物理层 Physical：负责比特流传输

OSI 七层模型的粒度过细，实际上更多采用的是 TCP/IP 四层模型，实际上就是 OSI 七层模型的包装和整合

1. 应用层：负责为用户程序提供完整的网络服务
2. 传输层：负责为进程提供端到端的可靠/不可靠传输
3. 网际层：负责路由选择和逻辑寻址
4. 网络接口层：负责底层的数据传输

![d5eec4dc32893dbad3587dd14cd7554d](https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/Java/202509290942466.png)

### 意义

- **独立**：每一层只需关注自己的职责，不必关心其他层的实现细节，一个层的改变不会影响整体网络结构
- **灵活**：下层只需向上层提供标准化接口，具体实现可以自由修改或替换
- **扩展**：不同厂商只要遵循统一的接口协议，就能实现兼容、升级和扩展
- **化简**：将复杂的网络通信问题分解为若干小问题，逐层实现，降低设计与理解的难度



## HTTP

### 定义

**HTTP（HyperText Transfer Protocol, 超文本传输协议）**是一种无状态、基于请求-响应模式的应用层协议，主要用于客户端和服务器之间的通信，规定了浏览器如何向 Web 服务器拿数据，以及 Web 服务器如何返回数据

- 无状态（stateless）：协议本身不保存会话信息
- 请求-响应模型：客户端主动请求，服务器被动响应
- 明文传输：不会进行加密，要么依靠应用层，要么使用 HTTPS
- 扩展：可以自定义请求头和响应头来实现不同效果
- 灵活：支持多种数据格式，包括 HTML、JSON、XML、图片、音频、视频等
- 可靠：基于 TCP，保证数据传输的不丢包、不乱序

### HTTP 报文

请求报文

- 请求行：` 方法 URI 协议版本>`
- 请求头：一组键值对，描述客户端的环境和请求信息
- 空行：分隔请求元信息和请求主体信息
- 请求体：携带表单数据、文件二进制流

```text
GET /index.html HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)
Accept: text/html,application/xhtml+xml,application/xml,*/*
Accept-Language: zh-CN,zh,en
Connection: keep-alive
```

响应报文

- 状态行：`<协议版本 状态码 状态描述>`
- 状态头：一组键值对，描述服务器的环境和响应信息
- 空行：分隔响应元信息和响应主体信息
- 响应体：携带 HTML、XML、JSON、文件二进制流

```text
HTTP/1.1 200 OK
Date: Sun, 29 Sep 2025 03:30:00 GMT
Server: Apache/2.4.41 (Ubuntu)
Content-Type: text/html; charset=UTF-8
Content-Length: 137

<html>
<head><title>Example</title></head>
<body>
<h1>Hello, World!</h1>
<p>This is a simple HTTP response.</p>
</body>
</html>
```

状态码和状态描述

| 状态码 | 状态含义      | 状态描述               |
| ------ | ------------- | ---------------------- |
| 1XX    | Informational | 💡 提示处理情况         |
| 2XX    | Success       | ✅ 请求处理完毕         |
| 3XX    | Redirection   | ↩️ 需要进一步请求       |
| 4XX    | Client Error  | ⚠️ 服务器无法处理请求   |
| 5XX    | Server Error  | ❌ 服务器处理请求时出错 |

头字段

| 名称                | 说明                               | 示例                                                  |
| ------------------- | ---------------------------------- | ----------------------------------------------------- |
| **Host**            | 指定请求的目标主机                 | Host: www.example.com                                 |
| **User-Agent**      | 客户端信息，如浏览器、设备、系统等 | User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) |
| **Accept**          | 客户端接收的内容类型               | Accept: text/html, application/json                   |
| **Accept-Language** | 客户端可接收的语言                 | Accept-Language: zh-CN, en-US                         |
| **Content-Type**    | 请求/响应体的数据类型              | Content-Type: application/json                        |
| **Content-Length**  | 请求/响应体的字节长度              | Content-Length: 348                                   |
| **Connection**      | 是否长连接                         | Connection: keep-alive                                |
| **Cookie**          | 客户端向服务器携带的 Cookie 数据   | Cookie: sessionId=abc123                              |
| **Set-Cookie**      | 服务器向客户端设置 Cookie          | Set-Cookie: sessionId=abc123; Path=/; HttpOnly        |

### TLS

要理解 TLS，首先需要理解三个有关安全的操作

| 类别     | 哈希 Hash                        | 加密 Encrypt                                                 | 签名 Signature                            |
| -------- | -------------------------------- | ------------------------------------------------------------ | ----------------------------------------- |
| **定义** | 把任意长度数据映射到固定长度的值 | 用密钥把明文转换为密文，再用密钥把密文还原为明文             | 先哈希消息得到摘要，再用密钥加密摘要      |
| **目的** | 防篡改                           | 防窃听                                                       | 防伪装                                    |
| **作用** | 做“指纹”，确保数据完整性         | 非对称加密用于保护密钥，对称加密用于保护传输数据             | 身份认证                                  |
| **可逆** | ❌ 不可逆                         | ✅ 可逆                                                       | ⚠️ 只能还原到摘要                          |
| 例子     | digest = Hash(plaintext)         | ciphetext = Encrypt(plaintext, key)<br />plaintext = Decrypt(ciphetext, key) | signature = Encrypt(Hash(plaintext), key) |

TLS 利用了四个技术确保了 HTTP 的安全性

- **对称加密**：加密和解密使用同一个密钥，效率都很高但是必须确保密钥不会泄漏，否则将彻底失去安全性
- **非对称加密**：加密和解密使用一对公钥和私钥，公钥加密只能用私钥解密，私钥加密只能用公钥解密，效率很低但是公钥泄漏对安全没有影响，因此**非对称加密在这里不是用于数据内容的，而是用于对称加密的密钥**
- **摘要算法**：实际上就是对输入数据进行哈希运算，得到固定长度的输出作为摘要，输入数据只要改动 1 个 bit，都会对摘要产生很大的影响，而且几乎不可能存在哈希冲突，因此摘要可以用来进行数据的完整性校验
- **数字证书**：由权威机构 CA（Certificate Authority）颁发，是对服务器的身份验证
    - **证书 Certificate**：服务器信息、服务器公钥、颁发者信息、有效期、序列号、签名算法（哈希算法+加密算法）
    - **签名 Signature**：使用证书中指定的签名算法和 CA 私钥生成对 Certificate 的签名

完整的流程为

1. 服务器提前向 CA 申请好数字证书并安装
2. 当客户端使用 https 第一次连接服务器的时候，会发送 ClientHello（包含客户端支持的加密算法列表和一个 ClientRandom）
3. 服务器会回复 ServerHello（包含数字证书、选定的加密算法和一个 ServerRandom）
4. 客户端利用 CertBody 中的签名算法中的哈希算法计算 Certificate 的 digest1，然后利用本地缓存的 CA 公钥对 Signature 进行解密得到 digest2，如果 digest1 == digest2 则说明验签成功，客户端认可服务器身份
5. 身份认证成功后，客户端就可以拿到 Certificate 中的服务器公钥
    1. 服务器会生成一个临时公私钥对（EphPub_server + EphPri_server），然后用服务器私钥对 EphPub_server 签名后发送，客户端用服务器公钥对 EphPub_server 验签后接收
    2. 客户端也会生成一个临时公私钥对（EphPub_client + EphPriv_client），然后直接明文把 EphPub_client 发送给服务器
    3. 客户端用 EphPriv_client + EphPub_server 而服务器用 EphPriv_server + EphPub_client 计算  pre-master secret
    4. 客户端和服务器再利用  pre-master secret + ClientRandom + ServerRandom 就可以得到最终的会话密钥 session_secret
6. 客户端会利用 session_secret 发送 Finished，服务器收到后也会利用 session_secret 返回 Finished
7. 当双方都收到 Finished 后就代表加密连接完成，可以开始加密传输

### HTTP vs HTTPS

实际上，HTTPS 就是比 HTTP 多了个 **TLS（Transport Layer Security）**，是 SSL（Secure Sockets Layer）的升级版

| **对比点**   | **HTTP**                   | **HTTPS**                                |
| ------------ | -------------------------- | ---------------------------------------- |
| **定义**     | 明文传输                   | 加密传输                                 |
| 前缀         | http://                    | https://                                 |
| **端口**     | 80                         | 443                                      |
| **性能**     | 无额外开销，速度快         | 有加解密开销                             |
| **证书**     | 不需要证书                 | 需要申请数字证书                         |
| **完整性**   | 无法保证数据是否被篡改     | 提供完整性校验，数据一旦被篡改就会被发现 |
| **应用场景** | 内网、对安全性要求低的场景 | 电商、支付、登录、敏感数据传输           |

### HTTP/1.0 vs HTTP/1.1

| **对比点**     | **HTTP/1.0**                                                 | **HTTP/1.1**                                                 |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **连接方式**   | 默认短连接：每次请求都要新建 TCP 连接，响应完立刻关闭        | 默认长连接：多个请求可复用同一个 TCP 连接                    |
| **带宽利用**   | 不支持范围请求，必须整个资源下载                             | 支持 Range 请求，可只请求部分内容                            |
| **缓存控制**   | 通过简单的 Expires 字段控制缓存，功能有限                    | 增强缓存控制，新增 Cache-Control、ETag、If-None-Match、If-Modified-Since 等更灵活的机制 |
| **Host 头部**  | 没有 Host 头部，一个 IP 地址只能绑定一个网站                 | 必须有 Host 头部，一个 IP 地址可以托管多个域名，推动了虚拟主机的发展 |
| 压缩           | 只支持端到端压缩，即资源本身被压缩了，不支持传输的时候会压缩 | 引入逐跳压缩，每一跳的中间节点都可能解码再编码               |
| **请求方法**   | GET、POST、HEAD                                              | 新增 PUT、DELETE、OPTIONS、TRACE 等                          |
| **错误状态码** | 只有 16 个                                                   | 引入新的状态码                                               |

### HTTP vs WebSocket vs SSE

| **特性**     | **HTTP**                               | **WebSocket**                                                | **SSE (Server-Sent Events)**                             |
| ------------ | -------------------------------------- | ------------------------------------------------------------ | -------------------------------------------------------- |
| **通信模式** | 半双工，客户端主动发起，服务器被动响应 | 全双工，客户端和服务器都能主动发消息                         | 单工，服务器主动发消息到客户端                           |
| **连接方式** | 短连接或长连接                         | 长连接                                                       | 长连接                                                   |
| **实时**     | 不实时，只能靠客户端轮询               | 实时双向通信                                                 | 实时单向推送                                             |
| **复杂度**   | 简单                                   | 较复杂，作为一个独立的应用层协议，需要服务端专门支持 WebSocket，也需要客户端调用 WebSocket API | 中等，封装在 HTTP 之上，使用 MIME 类型 text/event-stream |
| **使用场景** | 普通网页加载、表单提交、接口调用       | 聊天、协同编辑、游戏                                         | 消息推送、数据流更新                                     |

### Cookie

Cookie 从狭义上来讲就是**服务器要求存储在客户端的一个键值对**，服务器只需要在响应头中添加 `Set-Cookie` 来指定 `Name:Value` 和其属性

- **Domain**：指定生效的域名
- **Path**：指定生效的路径
- **Expires**/Max-Age：指定过期时间
- **HttpOnly**：禁止 JS 访问 Cookie
- **Secure**：只有在 HTTPS 才会传输
- **SameSite**：控制跨站请求时是否带 Cookie

```http
Set-Cookie: SESSIONID=abc123; Path=/; Domain=example.com; HttpOnly; Secure; Max-Age=3600; SameSite=Lax
```

Cookies 是浏览器当前在所有网站上保留的所有 Cookie，类似于一张表，浏览器会自动根据每个 Cookie 的属性来决定当前请求需要携带哪些 Cookie，从而在请求头中添加 `Cookie`，而且只需要加入 `Name:Value`，其他属性不需要加入

```http
Cookie: key1=value1; key2=value2; key3=value3
```

由于 Cookie 是明文存储的，所以 Cookie 不应该存储敏感信息，而是存储以下三类信息

- 存储用户偏好：浏览器进入某个页面可以直接切换到用户配置，如颜色、主题、快捷键、布局等
- 存储会话用户：在服务器创建 Session 对象代表当前对话并记录用户信息，但只保留一个 **JSESSIONID** 到客户端中，用来标识该 Session 对象
- 存储跟踪标识：广告商可以给当前主机设置一个 **TRACKINGID**，通过 JS 埋点，让浏览器每次请求都自动向广告商服务器发送一个携带 TRACKINGID 的请求，广告商就能在不同网站之间识别出同一个主机，从而构建操作当前主机的用户画像来实现精准投放

### CORS

**同源策略**：是浏览器的安全限制，**要求当前页面地址必须与请求资源地址的协议、域名、端口完全相同，才会允许 JS 代码访问响应数据**

- 像 \<img>、\<script>、\<link>、\<video>、\<audio> 等展示型资源的链接，JS 本来就不会访问响应数据，所以不会触发同源策略
- \<a> 跳转链接，不是让当前页面读取数据，而是直接换成了另一个页面，JS 代码会重新加载，所以也不会触发同源策略

**CORS（Cross-Origin Resource Sharing, 跨域资源共享）**：是一种基于 HTTP 响应头的机制，用来让浏览器确认某个跨域请求是不是被目标服务器允许的，如果目标服务器都允许了，那么浏览器自然没有拒绝的理由

| 类型     | 条件                                                         | 流程                                                         |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 简单请求 | - 方法：GET/HEAD/POST<br />- POST 的 Content-Type 只能是 application/x-www-form-urlencoded、multipart/form-data、text/plain<br />- 不能有自定义请求头 | 直接发请求，然后检查响应里的 Access-Control-Allow-Origin 是否包含当前域名 |
| 复杂请求 | - 方法：PUT/DELETE/PATCH<br />- 请求头中有自定义字段         | 先发送一个 OPTIONS 预检请求，然后根据服务器的响应来判断是否可以真的发送目标请求 |

```http
预检请求：
Origin: https://a.com
Access-Control-Request-Method: PUT
Access-Control-Request-Headers: Authorization

预检响应：
Access-Control-Allow-Origin: https://a.com
Access-Control-Allow-Methods: GET, POST, PUT
Access-Control-Allow-Headers: Authorization
```



## DNS

### 定义

**DNS（Domain Name System, 域名管理系统）**：用来**把域名解析为 IP 地址的系统**

- 域名：人类容易理解的主机名，如 www.example.com
- IP 地址：机器容易理解的主机名，如 192.168.24.1

DNS 服务器：实际上我们根本就无法通过域名来访问目标服务器，**域名本身并不是目标服务器的属性，只是为了方便人类记忆和理解的“逻辑别名”，目标服务器只能通过 ip 地址标识**，但是程序员在注册域名后，可以把域名和 ip 地址的映射关系保存在 DNS 服务器上，浏览器会在后台自动访问 DNS 服务器来实现域名解析

1. 用户在浏览器地址栏输入域名，浏览器会先查本地的 DNS 缓存（浏览器缓存、操作系统缓存、hosts 文件）
2. 如果没有查到就向本地 DNS 服务器发起请求，获取目标服务器域名对应的 ip 地址
3. 浏览器把域名作为请求头的一个字段，然后基于 TCP 和目标服务器的 ip 地址与目标服务器建立连接
4. 目标服务器根据域名确定处理请求的进程，然后返回响应

### DNS 服务器的类型和处理过程

1. **本地 DNS 服务器（local）**：一般由互联网服务提供商提供，实际上它并不能完全算作是 DNS 服务器，而是作为代理来递归访问真正的 DNS 服务器
2. **根域名服务器（root）**：根据域名后缀提供顶级域名服务器的 IP 地址
3. **顶级域名服务器（TLD）**：根据域名前缀提供权威域名服务器的 IP 地址
4. **权威域名服务器（authoritative）**：负责将域名映射到目标服务器的 IP 地址

> 由于根域名服务器的数量很少而且并不是均匀分布，显然不可能处理全球每秒几十亿的 QPS，实际上本地 DNS 服务器缓存了大量顶级域名服务器和权威域名服务器的 IP 地址，绝大部分请求都会直接跳过根域名服务器，甚至还会跳过顶级域名服务器

<img src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/Java/202509292227404.png" alt="image-20250929222756294" style="zoom:50%;" />

### DNS 记录

权威域名服务器在响应查询的是，会查询自己的数据库，其中的条目被称为资源记录（Resource Record, RR），是一个包含 Name、Value、Type 和 TTL 的四元组，不同的 Type 对应的 Name:Value 意义不同，而 TTL 是该资源记录的存活时间

> 在 DNS 配置里，**Name 是相对当前域名的写法，如果要表示当前域名则用 @**

| **Type** | **Name** | **Value**            | **说明**                         |
| -------- | -------- | -------------------- | -------------------------------- |
| A        | 域名     | IPv4 地址            | 把域名映射到 IPv4 地址           |
| AAAA     | 域名     | IPv6 地址            | 把域名映射到 IPv6 地址           |
| CNAME    | 域名     | 域名                 | 把一个域名设置为另一个域名的别名 |
| MX       | 域名     | 邮件服务器的域名     | 指定邮件服务器和优先级           |
| NS       | 域名     | 权威域名服务器的域名 | 指定管理该域名的权威域名服务器   |
| PTR      | IP       | 域名                 | 把 IP 地址映射回域名             |
| TXT      | 域名     | 文本信息             | 保存任意文本                     |

### DNS 劫持

**DNS 劫持（Hijacking）**指的是在 DNS 解析链路中被恶意篡改，使域名解析到错误的 IP，从而实现钓鱼、流量劫持、广告注入等

- 本地劫持：修改用户电脑上的本地 DNS 缓存，把域名解析为恶意 IP 地址
- 路由器劫持：修改路由器的 DNS 配置，把解析请求指向恶意 DNS 服务器
- 权威域名服务器劫持：如果用户关于域名注册商的账号密码丢失，黑客可以直接修改 A 记录解析为恶意 IP 地址



## TCP

### 传输区分

**TCP（Transmission Control Protocol, 传输控制协议**） 和 **UDP（User Datagram Protocol, 用户数据报协议）** 属于运输层协议，它们都是通过端口号来实现不同进程间的通信

| 层次   | 核心协议         | 依赖     | 通信对象 | 数据单元                         |
| ------ | ---------------- | -------- | -------- | -------------------------------- |
| 应用层 | HTTP             | 套接字   | 应用程序 | 报文 Message                     |
| 传输层 | TCP / UDP        | 端口     | 进程     | 字节段 Segment / 数据报 Datagram |
| 网络层 | IP               | ip 地址  | 主机     | 数据包 Packet                    |
| 链路层 | Ethernet / Wi-Fi | mac 地址 | 网卡     | 帧 Frame                         |

### UDP 区别

| 特性         | TCP                                  | UDP                                |
| ------------ | ------------------------------------ | ---------------------------------- |
| **连接性**   | 面向连接：三次握手、四次挥手         | 无连接：直接发，不建立连接         |
| **可靠性**   | 可靠传输：确认 ACK、重传、顺序控制） | 不可靠传输：可能丢包、乱序、不重传 |
| **传输形式** | 字节流：没有边界，连续的数据流       | 数据报：有边界，一次发送一次接收   |
| **状态维护** | 有状态：序列号、窗口大小             | 无状态                             |
| **传输效率** | 慢：握手+重传+拥塞控制               | 快：无握手、无确认                 |
| **头部开销** | 大：头部至少 20 字节                 | 小：头部固定 8 字节                |
| **通信模式** | 只支持点对点的单播                   | 支持单播、多播和广播               |
| **流量控制** | ✅                                    | ❌                                  |
| 拥塞控制     | ✅                                    | ❌                                  |
| **应用场景** | HTTP/1.1、FTP、SMTP、SSH             | HTTP/3、DNS、VoIP、游戏            |

### 三次握手

由于**TCP 把传输的数据看作成字节流，每次传输都是传输一段连续的字节，因此为了确保字节的按序传输，TCP 会给每个字节都编号**，并在传输的字节段 Segment 带上两个重要编号

- **序列号（Sequence）**：表示本方**当前发送**的**第一个字节**的编号 seq，负责告诉接收方**当前 Segment 的起始字节**
- **确认号（Acknowledgement）**：表示本方**期望接收**的**下一个字节**的编号 ack，负责告诉接收方**在 ack 之前的数据都已经收到**

> 第一次握手和第二次握手生成的序列号 x, y 是随机的

![image-20250930092837451](https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/Java/202509300928072.png)

### 四次挥手

由于 TCP 是全双工通信，因此为了结束通信，双方都要发送一个 FIN，并接收到对方传来的 ACK 才能达成共识结束断开 TCP

- 发送方发送 FIN 不能确认发送方结束：发送方不保证可以如期收到 ACK
- 接收方收到 FIN 可以确认发送方结束：在 TCP 协议中，FIN 是不可撤销的，接收方没有任何手段阻止发送方关闭连接
- 发送方收到 ACK 可以确认发送方结束：发送方确认接收方知道自己关闭了才能放心地关闭

> 这里的确认号为 - 不代表没有意义，而是它与四次挥手没有关系

![image-20250930101244093](https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/Java/202509301012195.png)

WAIT 状态分析

| WAIT 状态      | 等待主体 | 等待对象          | 意义                                                         |
| -------------- | -------- | ----------------- | ------------------------------------------------------------ |
| **FIN_WAIT_1** | 主动方   | 主动方 FIN 的 ACK | 主动方发送完全部内容了，发送 FIN 确定要关闭                  |
| **FIN_WAIT_2** | 主动方   | 被动方的 FIN      | 主动方收到自己 FIN 的 ACK 了，但是还需要接收被动方没有发送完的内容 |
| **CLOSE_WAIT** | 被动方   | 待发送数据        | 被动方需要保证自己原本要发送的内容发送完，不能中途断开       |
| **LAST_ACK**   | 被动方   | 被动方 FIN 的 ACK | 被动方发送完全部内容了，发送 FIN 确定要关闭                  |
| **TIME_WAIT**  | 主动方   | 2 * MSL           | 如果在两个 MSL（Max Segment Lifetime, 报文段最长寿命时间）内主动方没有收到任何东西，则说明被动方成功接收了 ACK 并已经下线，否则被动方一定会重发 FIN |

### 编号变化

需要注意的是，字节编号并不是对所有传输的字节编号，而仅仅针对 Segment 中的有效载荷，也就是说，如果没有有效载荷，那么序列号可能不会被消耗，但也存在特殊情况

- 在三次握手过程中，**客户端和服务器的 SYN 即使没有有效载荷也会消耗一个序号**
- 在四次挥手的过程中，**客户端和服务器的 FIN 即使没有有效载荷也会消耗一个序号**
- 在数据传输的过程中，理想情况下的序号变化为：
    - **send_ack = recv_seq + n**：期望接收的下一字节编号 = 当前接收的起始字节编号 + 当前接收的有效载荷字节数量，需要注意的是**从 recv_seq 开始的 n 个字节是到 recv_seq + n - 1**
    - **send_seq = recv_ack**：这只是非常理想，即不出现任何乱序和错误的情况，实际上序列号完全取决于发送方维护的窗口值，**跟 ack 没有一点关系**

![image-20250930115549534](https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/Java/202509301155652.png)

### 可靠性

**TCP 提供的可靠性不是说 TCP 可以确保网路传输不会发生错误**，实际上 TCP 底层需要依靠 IP 协议，而 IP 协议是不可靠的，网络层很可能会发生丢包错误。由于层次隔离性，TCP 不可能干预网络层，做到杜绝丢包事件，但是 TCP 可以通过可靠性手段在传输层来**减少丢包率和处理丢包错误**，从而保证**在传输层能最终获取到正确数据**

- **RTO（Retransmission Time Out, 重传超时时间）**：发送方等待 ACK 的时间
- **RTT（Round Trip Time, 往返时间）**：从发送方发出一个数据包，到收到对应的 ACK 的时间
- RTO 必须比 RTT 大一些，有专门的算法来计算，因为**太小会误判丢包，太大会延迟重发**

| 手段     | 依赖                                                | 解决             | 说明                                                         |
| -------- | --------------------------------------------------- | ---------------- | ------------------------------------------------------------ |
| 差错检验 | Segment 头中的 checksum 字段                        | 处理网络波动错误 | 发送方会把自己计算的校验和结果放到 Segment 中，如果接收方重新计算的结果不一致，则认为数据出错，直接丢弃 |
| 缓存     | 接收缓冲区                                          | 处理网络乱序错误 | 接收方可缓存乱序到达的段，并根据序列号重新排序               |
| 重传     | ACK 机制                                            | 处理网络丢包错误 | TCP 协议中，如果一切正常，接收方会返回一个 ACK 给发送方表示成功接收，同时确认号会随着序列号变化而变化，所以如果：<br />- 接收方**在超时时间内没有收到 ACK**，则重发<br />- 接收方**连续收到三个一样的 ACK**，则重发 |
| 流量控制 | 接收方维护的 rwnd 变量和 Segment 头中的 window 字段 | 减少接收方丢包率 | rwnd 变量记录了**接收方还剩余多少接收缓存空间可以用**，每次返回 ACK 的时候把 rwnd 的值填入 window 字段，强制要求发送方下一次发送的字节数不允许超过这个值 |
| 拥塞控制 | 发送方维护的 cwnd 变量                              | 减少网络丢包率   | cwnd 变量记录了**发送方认为当前网络可承载的最大数据量**，不会把 rwnd 传给接收方，而是根据 **min(cwnd, rwnd)** 来确定当前最多可以发送的字节数 |

### 拥塞控制算法

rwnd 的值很简单，自己的接收缓冲区剩多少就是多少，但是 cwnd 的值是估计出来的，会按照拥塞控制算法，随着网络状况变动而动态改变的

1. 慢启动：初始令 cwnd = 1，每收到一个 ACK 就让 cwnd = cwnd * 2（指数增长），当达到预先设置的慢启动阈值 ssthresh 时，就会切换到拥塞避免
2. 拥塞避免：每收到一个 ACK 就让 cwnd = cwnd + 1（线性增长），当发生丢包时，会根据丢包原因切换到慢速恢复/快速恢复
3. 慢速恢复：如果是在超时时间内没有收到 ACK，则认为是网络丢包，令 ssthresh = cwnd / 2, cwnd = 1，切换到慢启动
4. 快速恢复：如果是连续收到三个一样的 ACK，则认为是接收方丢包，令 ssthresh = cwnd / 2, cwnd = cwnd / 2 + 3，切换到拥塞避免

> **MSS（Maximum Segment Size, 最大报文段长度）**：是 cwnd 的数值单位，**表示报文段中能携带的最大应用层数据长度，不包括 TCP/IP 头部**。通常来说以太网的最大传输单元是 1500 字节，而 IP 头部和 TCP 头部各占 20 字节，所以 MSS 一般是 **1460** 字节

![7e73b59156ea260355233f9ff0b7b5df](https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/Java/202509301502222.png)



## IP

### 定义

**IP（Internet Protocol, 网际协议）**：是网络层的协议，用于定义数据包的格式，并对数据包进行**路由和寻址**，确保数据包可以跨网络传播，并正确到达指定主机，但只能提供**尽力而为的无连接传输服务**，可能会发生丢包错误

### IP 地址

理解 IP 协议的关键就是理解 IP 地址，IPv4 地址是一个 32 位比特串，通常将每 8 位转换为成一个十进制数，之间用 `.` 分隔，大约可以表示 43 亿个地址，而每个 IP 地址会被划分为网络号+主机号两部分

- **网络号（Network ID）**：用 IP 地址的前位来标识网络，从而将整个互联网划分为不同的子网，用于路由转发
- **主机号（Host ID）**：用 IP 地址的后位来标识主机，从而区分每个子网内的不同主机，用于主机寻址
- **子网掩码（Subnet Mask）**：专门用来区分网络号和主机号的工具，是一个 32 位的数，1 表示这一位属于网络号，0 表示这一位属于网络号，所以 IP 地址 & 子网掩码 = 网络号
- **CIDR（Classless Inter-Domain Routing, 无类域间路由）**：在 IP 地址后直接加 /n，表示前 n 位是网络号，后面是主机号

> IP 地址 → 192.168.10.25 → 11000000.10101000.00001010.00011001
>
> 子网掩码 → 255.255.255.0 → 11111111.11111111.11111111.00000000
>
> 主机号 → 192.168.10.0 → 11000000.10101000.00001010.00000000

这样做的原因主要有三点

- **路由转发更高效**：路由器转发数据包不需要关心主机号，只需要根据子网掩码查看目标 ip 的网络号
- **避免地址浪费**：传统 A/B/C 类地址的网络号位数是固定的，多一位就可能会导致大量浪费，而子网掩码可以精细控制子网大小
- **清晰的网络组织和隔离**：网络号可以把全球互联网划分为有边界的子网，让子网间互不干扰

### 获取真实 IP

| 方法            | 途径            | 优点                                        | 缺点                                        |
| --------------- | --------------- | ------------------------------------------- | ------------------------------------------- |
| RemoteAddr      | TCP 连接的源 IP | 不可伪造，来源真实                          | 可能是代理/NAT/CDN 的 IP，而非客户端真实 IP |
| X-Real-IP       | 由反向代理设置  | 最直接，配置好就能准确获取客户端 IP         | 必须依赖代理配置，配置错误会导致取值不对    |
| X-Forwarded-For | HTTP 头         | 可以追踪多级代理，第一个 IP 通常是客户端 IP | HTTP 头可伪造，必须只信任可信代理/CDN 注入  |

### 特殊 IP 地址

这些 IP 地址是保留起来作为特殊用途，不会被设置为主机的 IP 地址

| IP 地址          | 名称                | 用途                                             |
| ---------------- | ------------------- | ------------------------------------------------ |
| 0.0.0.0          | 未指定地址/任意地址 | 设备启动时或服务器绑定本地所有网卡               |
| 127.0.0.1        | 回环地址            | 数据会直接返回本机，不会经过网络，常用于本地测试 |
| 255.255.255.255  | 本地广播地址        | 向当前子网内所有主机发送数据                     |
| <网络号>.0       | 网络地址            | 标识子网本身，不可分配给主机                     |
| <网络号>.255     | 直接广播地址        | 向某个特定子网的所有主机广播                     |
| 192.168.0.0 / 16 | 私有地址            | 小型内网，作为 NAT 的内网接口                    |
| 172.16.0.0 / 12  | 私有地址            | 中型内网，作为 NAT 的内网接口                    |
| 10.0.0.0 / 8     | 私有地址            | 大型内网，作为 NAT 的内网接口                    |



## NAT

### 定义

**NAT（Network Address Translation, 网络地址转换）**一种运行在**路由器**上的地址转换技术，**把局域网的私有 IP 映射为广域网的公网 IP**

- **广域网 / 公网 / 外网（WAN, Wide Area Network）**：覆盖范围大，跨城市、国家和全球，主要用于把不同局域网连接起来，IP 地址不可重复
- **局域网 / 外网 / 内网（LAN, Local Area Network）**：覆盖范围小，跨家庭、学校和公司，主要用于把不同设备连接起来，IP 地址可以重复

### 类别

| 方法     | 功能                                                         | 性质                                                      |
| -------- | ------------------------------------------------------------ | --------------------------------------------------------- |
| 静态 NAT | 用一张表记录固定映射关系，一个内网 IP ↔ 一个公网 IP          | 最方便，但浪费公网 IP，表也很消耗存储空间                 |
| 动态 NAT | 用一个池子存储可用的公网 IP，在内网 IP 出网时动态从池子中分配一个公网 IP | 节省公网 IP，但动态分配会损失性能，而且分配完可能导致阻塞 |
| PAT      | 多个内网 IP 共享同一个公网 IP，通过端口号来区分不同连接      | 只需要一个公网 IP                                         |

### 意义

- 核心：通过局域网划分，让内网地址可以重复利用，从而极大程度地缓解了 IPv4 地址耗尽问题
- 安全：NAT 向 WAN 屏蔽了 LAN，外部只能看到路由器的公网 IP，看不到真实的内网 IP
- 灵活：内网地址可以随机规划和更改，完全不影响公网通信；公网地址也可以随机更换，完全不需要通告内网

![image-20251001145820870](https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/Java/202510011458017.png) 



## ARP

### MAC 地址

MAC 地址（Media Access Control, 媒体访问控制）是**网卡的硬件地址**，全球唯一，长度为 48 位，通常写成 6 段十六进制数，中间用 `:` 分隔，用于在链路层中标识目标设备，实现数据帧的传输

需要注意的是，MAC 地址虽然是全球性的，但是 MAC 地址的作用范围只局限在一跳之内，每经过一跳，目标 MAC 地址都会动态变化，从而一跳一跳地到达目的地

| 维度     | MAC                                             | IP                                         |
| -------- | ----------------------------------------------- | ------------------------------------------ |
| 示例     | 00:1A:2B:3C:4D:5E                               | 192.168.1.1                                |
| 层次     | 链路层                                          | 网络层                                     |
| 长度     | 48 位                                           | 32 位                                      |
| 标识性质 | 逻辑标识                                        | 物理标识                                   |
| 分配方式 | 厂商烧录到网卡                                  | 网络管理员分配                             |
| 地址唯一 | 全球唯一                                        | 内网唯一                                   |
| 主机数量 | 取决于网卡数量：不同 MAC 地址负责不同的传输渠道 | 取决于网络管理员：不同 IP 地址负责不同服务 |
| 是否可改 | 不可改                                          | 随时修改                                   |
| 作用域   | 一跳                                            | 端到端（不考虑地址变化）                   |

### 网卡

**网卡/网络接口卡（Network Interface Card, NIC）**：每个具备联网功能的主机都必须有的硬件，它是主机连接网络的硬件接口，**真正负责数据在主机与网络之间的收发，每个网卡只能有一个 MAC 地址，但是可以有多个 IP 地址**

- 发送：解析网络层传下来的 IP 数据包，先封装上自己的 MAC 地址作为源 MAC 地址，然后根据 ARP 协议封装上下一跳 MAC 地址形成数据帧，再把帧转换成电信号、光信号或无线电波发送到物理介质中
- 接收：从物理介质中接收信号还原为数据帧，根据帧头中的目标 MAC 地址判断是否是自己的 MAC 地址，如果是就交给操作系统的上层协议栈继续处理

### ARP 表

ARP 表存储了 IP 地址 → MAC 地址的映射，但是这个映射关系**不是表示目标 IP 地址对应的目标 MAC 地址，而是表示为了到达目标 IP 地址，下一跳应该跳到什么 MAC 地址**

| **对比维度** | **路由表**                                   | **ARP 表**                       |
| ------------ | -------------------------------------------- | -------------------------------- |
| **作用层次** | 网络层                                       | 链路层                           |
| 条目内容     | 目标网络, 子网掩码, IP 地址, 接口 id, 度量值 | IP 地址, MAC 地址, TTL           |
| **映射关系** | 目标网络 → 出接口 + 下一跳 IP 地址           | 下一跳 IP 地址 → 下一跳 MAC 地址 |
| **动态填充** | RIP / OSPF / BGP                             | ARP                              |
| **举例**     | 10.0.0.0/8 → 192.168.1.1                     | 192.168.1.1 → aa:bb:cc:dd:ee:ff  |

### 工作流程

ARP 表必须依赖路由表，不能单独发挥作用，因为 ARP 表映射的是下一跳 IP 地址到下一跳 MAC 地址，而下一跳 IP 地址是根据路由表得到的

1. 当主机要发送一个 IP 包时，先查路由表
    - 如果目标 IP 在本地子网，下一跳就是主机
    - 如果目标 IP 不在本地子网，下一跳就是网关
2. 确定了下一跳 IP 地址之后，再查 ARP 表
    - 如果有记录，直接得到对应的下一跳 MAC 地址
    - 如果没有记录，会发送 ARP 请求，从 ARP 响应中得到下一跳 MAC 地址
3. 设置数据帧的源 MAC = 本机网卡 MAC，目标 MAC = 下一跳 MAC，然后将帧发送出去

### ARP 请求

ARP 请求报文包含源 MAC 地址、源 IP 地址、目标 IP 地址和目标 MAC 地址，需要注意的是，**这四个是报文本身的内容，不属于数据包头或数据帧头，实际上 ARP 请求报文只是一个数据帧，根本没有 IP 头**

1. **将数据帧头中的目标 MAC 地址填全 1，将数据帧内容中的目标 MAC 地址填全 0**，表示将请求广播到所有主机
2. 当某个主机收到 ARP 请求后，**发现内容中的目标 IP 地址是自己的 IP 地址，会根据内容中的源 MAC 地址单播一个 ARP 响应报文**，其他主机则直接忽略
3. 当发送方收到 ARP 响应后，会拿到内容中的源 MAC 地址来更新 ARP 表



## 网关 Gateway

### 定义

- 广义上是一个**网络节点**，负责把数据从一个终端节点转发到另一个终端节点，如路由器、防火墙、NAT 设备
- 狭义上是一个**路由器入接口**，负责根据自己的路由表转发到对应出接口，并根据 ARP 表得到下一跳 MAC 地址

### 路由协议

网关除了支持 IP、ARP、NAT 等有关地址的协议外，还支持以下路由协议

| **协议** | **类型**     | **算法**                | **度量** | **更新方式**           | **适用场景** |
| -------- | ------------ | ----------------------- | -------- | ---------------------- | ------------ |
| RIP      | 内部网关协议 | 距离向量 + Bellman-Ford | 跳数     | 周期性广播整个路由表   | 小规模内网   |
| OSPF     | 内部网关协议 | 链路状态 + Dijkstra     | 开销     | 链路变化时触发泛洪更新 | 大规模内网   |
| BGP      | 外部网关协议 | 热土豆 / 消除规则       | 策略     | 邻居间按需交换路径信息 | 跨域互联     |



## 访问 URL 全过程

```url
http://www.example.com/index.html
```

1. 浏览器解析 URL，得到：协议 HTTP、域名 www.example.com、端口号 80、资源 /index.html
2. 浏览器调用操作系统的 DNS 解析模块，首先检查本地 DNS 缓存，如果没有的话则利用本地 DNS 服务器递归查询，得到 www.example.com 对应的 IP 地址 23.46.216.71
3. 浏览器作为客户端和位于 23.46.216.71 的服务器通过三次握手建立 TCP 连接
4. 浏览器构造 HTTP 请求报文 `GET /index.html HTTP/1.1`，通过 TCP 发送给服务器
5. 如果目标 IP 不在本地子网，操作系统会把数据包发送到默认网关
6. 网关将数据包的源 IP 地址从内网地址 192.168.1.100 改为公网地址 203.0.113.5
7. 网关先查自己的路由表得到目的 IP 地址对应的下一跳 IP 地址，然后再查自己的 ARP 表得到下一跳 IP 地址对应的下一跳 MAC 地址，以此类推，直到到达目标服务器
8. 浏览器收到了 HTTP 响应报文，解析 HTML，渲染页面













