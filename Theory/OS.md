# OS



## 内核

### 定义

**操作系统（Operating System, OS）是计算机系统中管理硬件与软件资源的系统软件，为用户和应用程序提供统一接口和运行环境，包含内核、系统库和系统工具**

- **抽象**：屏蔽硬件差异，为应用程序提供统一接口
- **管理**：高效利用 CPU、内存、IO 等硬件资源
- **隔离**：不同进程之间互不干扰，保证安全
- **共享**：让多个应用程序能够公平高效地使用资源

<img src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/Java/202510011945701.png" alt="image-20251001194553633" style="zoom:50%;" />

**内核（Kernel）是操作系统的核心部分，常驻于内存，负责直接管理 CPU、内存、I/O**

- **内核代码**：执行特权指令和特殊操作的代码，如系统调用、中断处理、异常处理等例程
- **内核数据**：保存系统运行时的全局状态信息，如进程控制块、页表、文件描述符表等
- **内核线程**：内核代码直接创建的线程，不依赖于任何进程，可以直接被调度器调度执行，负责处理内核的后台任务，如内存回收、日志写盘等

| **管理** | **负责**                                                     | **意义**                                     |
| -------- | ------------------------------------------------------------ | -------------------------------------------- |
| 进程管理 | 进程生命周期、进程间通信和同步，调度进程并发执行             | 让多任务安全高效地运行，保证系统公平和响应性 |
| 内存管理 | 内存分配和回收，提供虚拟内存，隔离不同进程的地址空间         | 提高内存利用率，保证进程之间互不干扰         |
| 文件管理 | 文件的创建、删除、读写和权限控制，提供统一的文件系统接口     | 让应用程序以统一方式访问数据，保障安全和共享 |
| 设备管理 | 把硬件设备抽象为设备文件，通过驱动程序实现 I/O 操作          | 屏蔽硬件差异，简化应用对设备的使用           |
| 网络管理 | 提供套接字接口，负责数据封装、传输和解包，实现主机间远程通信 | 让分布式应用和网络服务能够互联互通           |

### 用户态和内核态

用户态和内核态指的是 **CPU 的运行模式和权限等级（privilege level）**，而不是程序或进程的状态

| 维度     | 用户态                                 | 内核态                         |
| -------- | -------------------------------------- | ------------------------------ |
| 运行权限 | 低，只能访问用户内存，不能直接操作硬件 | 高，可以直接访问所有硬件和内存 |
| 运行对象 | 用户线程 / 用户代码                    | 内核线程 / 内核代码            |

CPU 要么运行在用户态，要么运行在内核态，这样做的原因是：

- **安全性**：限制应用程序，避免直接操作硬件
- **稳定性**：隔离应用程序和内核，应用崩溃只会影响自己，系统仍可以继续运行
- **可控性**：硬件只交给内核管理，所有特权指令由内核统一执行，

CPU 可以从用户态切换到内核态

- **系统调用（System Call）**：当应用程序需要执行受保护的操作时，可以主动通过系统调用，切换到内核中的特定例程执行，从而实现用户态 → 内核态
- **中断（Interrupt）**：当外部硬件完成用户请求的特权操作后，会主动向 CPU 发出中断信号，CPU 会暂停当前应用程序的执行，切换到内核中的中断服务程序执行，从而实现用户态 → 内核态
- **异常（Exception）**：当 CPU 在执行指令检测到错误的时候，会切换到内核中的异常处理程序执行，从而实现用户态 → 内核态
- **返回（Return）**：当系统调用 / 中断 / 异常处理完成后，CPU 会通过返回指令回到原来的执行点，从而实现内核态 → 用户态
- **调度（Schedule）**：当内核决定切换进程时，CPU 会保存当前进程的上下文并恢复新进程的上下文，从而实现内核态 → 用户态

### 系统调用

系统调用：是用户态进程通过 Trap 指令进入内核态并请求执行内核服务中的特权指令的唯一接口

- **特权指令**：用于执行敏感操作，**是内核态才能运行的 CPU 指令**，可能会影响整个系统的安全，如操作硬件和内存
- **Trap 指令**：是一类特殊的 CPU 指令，只有执行它才可以从用户态切换到内核态，并跳转到预定义的处理入口，常用于系统调用和异常处理

- **系统调用表**：内核里的一张映射表，**将系统调用号映射到内核服务函数的入口地址**

系统调用即可以理解为一个内核服务的入口地址，也可以理解为一整个执行敏感操作的过程

1. **应用程序调用库函数**：执行用户代码 `write(fd, buf, len)`
2. **触发 Trap 指令**：先将参数和系统调用号放到指定寄存器，然后执行库函数底层指令 `syscall`
3. **进入内核态**：CPU 从用户态切到内核态，并跳转到内核的系统调用入口
4. **执行内核例程**：执行内核代码 `sys_write()`
5. **返回用户态**：执行 `iret` / `sysret` 切回用户态，继续执行应用程序后面的指令

> 需要注意的是，执行内核代码的依然是应用程序自己的进程/线程，并不存在一个专门的“内核进程”来帮你执行，也不是通过消息机制交给“内核线程”去处理



## 进程

### 对比

**程序（Program）**：是存放在磁盘上的可执行文件，是静态的代码和数据，本身不会允许

**进程（Process）**：是程序被加载到内存后的运行实例，一个程序对应一个进程，但进程本质上只是一个承载程序的资源容器，并不能看作为运行单位

**线程（Thread）**：是真正执行程序的主体，可以获得 CPU 时间片

| **对比维度** | **进程**                     | **线程**                                       |
| ------------ | ---------------------------- | ---------------------------------------------- |
| **基本单位** | 资源分配                     | 调度                                           |
| **地址空间** | 有独立的虚拟地址空间         | 共享进程的地址空间                             |
| **资源**     | 重量级：有独立完整的资源     | 轻量级：共享进程资源，但有自己独立的栈和寄存器 |
| **切换开销** | 大：虚拟内存切换、页表切换   | 小：保存/恢复线程上下文                        |
| **通信方式** | 进程间通信                   | 读写共享内存                                   |
| **健壮性**   | 一个进程崩溃不会影响其他进程 | 一个线程崩溃可能导致所属的进程崩溃             |

### 多线程的意义

- **提高并发性能**：线程是轻量级的，创建、销毁、通信和上下文切换的开销都更小
- **提高 CPU 利用率**：当一个线程因 I/O 阻塞无法继续执行时，CPU 可以切换去运行其他线程，从而避免 CPU 空转
- **提高系统效率**：在多核 CPU 环境下，不同线程可以分布在多个核心上并行执行，显著提升整体执行效率（前提是没有严重的竞争）

### PCB

**进程控制块（Process Control Block, PCB）**：是操作系统用来管理进程的核心数据结构，保留了进程的所有信息，每个进程对应一个 PCB

- **标识信息**：进程 ID（PID）、父进程 ID（PPID）、用户 ID（UID）
- **状态信息**：程序计数器、各种寄存器的值
- **调度信息**：进程状态、进程优先级、调度队列指针
- **内存信息**：基址、大小、页表、段表
- **文件信息**：打开的文件列表、文件描述符
- **记账信息**：占用 CPU 时间、使用的资源量

> 每个线程也有自己的 TID，但是只有主线程的 TID = PID

### IPC

**进程间通信（Inter-Process Communication, IPC）**指不同进程之间交换数据、传递信息的一类机制，而不是某个具体的方法

- **管道**：单向通信通道，一个进程写、一个进程读，数据遵循 FIFO
    - **匿名管道**：在内存中临时存在，用于具有亲缘关系的父子进程间或者兄弟进程之间的通信
    - **有名管道**：以磁盘文件方式持久存在，用于任意两个进程通信
- **消息队列**：内核维护一个消息链表，任意多个进程可以向队列里写消息、读消息，支持随机读取
- **共享内存**：多个进程映射到同一块物理内存，直接读写，效率最高，但需要同步手段（如信号量）避免竞争
- **信号**：向进程异步发送特定信号，另一个进程可选择性捕获，常用于通知接收进程某个事件，只是单向通信
- **套接字**：既可以用于同一台主机的进程通信，也可以用于不同主机之间的网络通信，支持双向通信

### 进程状态

进程状态用于描述进程在生命周期中所处的运行阶段，反映进程与系统资源的关系

- **创建 NEW**：刚刚被创建，正在分配资源，还没进入就绪队列
- **就绪 READY**：获得了所有资源，进程已具备运行条件，等待调度执行
- **运行 RUNNING**：正在 CPU 上运行
- **阻塞 WAITING**：等待某一事件/等待某资源可用/等待某 IO 执行完毕
- **结束 TERMINATED**：刚刚退出或者被杀死，正在回收资源

<img src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/Java/202510030012666.png" alt="image-20251003001235002" style="zoom:50%;" />

### 调度算法

调度算法是操作系统在多个就绪进程之间决定谁获得 CPU 使用权的策略，用于提高系统的响应性与吞吐量

| **调度算法**                                        | **策略**                                     | **优点**                           | **缺点**                                                |
| --------------------------------------------------- | -------------------------------------------- | ---------------------------------- | ------------------------------------------------------- |
| **先来先服务 (FCFS, First Come First Served)**      | 按到达顺序排队，先到先运行                   | 实现简单，公平性好                 | 平均等待时间可能长，对长作业有利、对短作业不利          |
| **短作业优先 (SJF, Short Job First)**               | 优先执行运行时间最短的进程                   | 平均等待时间最短，整体吞吐量高     | 需要预估作业运行时间，长作业可能长期得不到执行          |
| **时间片轮转 (RR, Round-Robin)**                    | 每个进程按时间片轮流执行                     | 响应快，适合交互式系统             | 时间片过大 → 退化成 FCFS；时间片过小 → 上下文切换开销大 |
| **优先级调度（Priority）**                          | 按优先级高低选择进程执行                     | 灵活，可满足不同任务需求           | 低优先级进程可能长期得不到执行                          |
| **多级反馈队列 (MLFQ, Multi-level Feedback Queue)** | 多个队列，优先级逐级下降，同个队列内按照 SJF | 不需要预估作业时间，能兼顾长短作业 | 实现复杂，参数难以调优                                  |

### 特殊进程

- 0 号线程 / idle 线程：内核在完成系统初始化后，把自己注册为线程，负责在系统空闲时运行 idle 任务，防止 CPU 空转
- 1 号进程 / init 进程：由 0 号进程 `fork()` 的第一个用户态进程，是所有用户进程的祖先进程，负责启动系统服务，并“收养”孤儿进程
- 2 号线程 / kthreadd 线程：由 0 号进程通过 `kernel_thread()` 创建的第一个内核态线程，是所有内核线程的祖先线程，负责统一创建与管理内核中的其他线程
- 僵尸进程（Zombie）：子进程已经终止执行，但是父进程没有调用 `wait()` 导致子进程的 PCB 依然保留在内核中，占据了 PID 和内核内存
- 孤儿进程（Orphan）：父进程已经退出但子进程仍在运行，只能交给 init 进程调用 `wait()` 回收



## 死锁

### 定义

死锁（Deadlock）：一组并发进程因相互占有对方所需资源并彼此等待，形成等待环路而无限期阻塞

- 互斥：资源同个时间内只能被一个进程占有
- 占有并等待：一个进程占有一个资源并且等待另一个被其他进程占有的资源
- 非抢占：进程不能抢占其他进程已占有的资源
- 循环等待：存在一条进程-资源的环形等待链

> 满足四个条件也不一定会死锁，但是死锁一定会满足这四个条件

### 预防

**静态分配**：破坏占有并等待，一个进程只有获得了所有需要的资源才会运行，而不是在运行过程中动态申请资源

**层次分配**：破坏循环等待，为所有资源分配一个整数编号，要求进程按递增顺序来申请资源

### 避免

安全状态：存在一个进程执行顺序，使得所有进程都可以依此获得它们所需的资源并顺利完成，不会发生死锁状态

> 安全状态一定不死锁，非安全状态可能死锁

| **名称**          | **含义**                           |
| ----------------- | ---------------------------------- |
| Available[j]      | 当前可用的第 j 类资源数            |
| Allocation\[i][j] | 当前已分配给进程 i 的第 j 类资源数 |
| Need\[i][j]       | 当前进程 i 还需要的第 j 类资源数   |

银行家算法：假设某个进程 Pᵢ 发出请求 Request[j]：

1. 检查请求合理性
    - 如果 Request[j] > Need\[i][j] → 进程申请超过需求
    - 如果 Request[j] > Available[j] → 资源不足
2. 预分配资源
    - Available[j] -= Request[j]
    - Allocation\[i][j] += Request[j]
    - Need\[i][j] -= Request[j]
3. 检查安全状态
    1. 令所有 Finish[i] = false，表示进程是否可完成
    2. 找到一个满足 Finish[i] = false 且 Need\[i][j] <= Available[j]
    3. 如果可以找到，则可认为该进程可以执行完，令 Finish[i] = true 且 Available[j] += Allocation\[i][j]，然后回到步骤 2
    4. 如果所有进程都可以 Finish[i] = true，那么当前系统就出于安全状态，否则处于不安全状态
4. 如果预分配资源后，检查为安全状态，则提交预分配，接受请求；否则回滚预分配，拒绝请求

### 检测 + 解除

用资源分配图描述进程和资源之间的占有和等待关系，如果资源分配图中存在环

- 单实例资源：一定死锁
- 多实例资源：可能死锁

![image-20251004150556006](https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/Java/202510041505084.png)

检测到死锁发生时，需要解除死锁，让系统恢复到正常情况

- 资源剥夺：强制从部分进程回收资源并分配给等待进程
- 进程回滚：回滚到上一个安全状态再重新运行
- 进程撤销：撤销所有进程 / 撤销所有导致死锁的进程 / 撤销死锁中优先级低的进程



## 内存管理

### 内存分配

#### 内存碎片

碎片：没有有效利用的内存空间

外部碎片：已分配内存之间的不连续空闲缝隙，过小导致无法作为分配对象

内部碎片：分配内存比所需内存多出的空间片段，被进程占有却没有被进程使用

<img src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/Java/202510041529784.png" alt="image-20251004152907703" style="zoom:50%;" />

#### 连续内存分配

固定分区：把内存提前划分为若干固定大小的分区，每个进程固定装入一个分区，没有外部碎片但是内部碎片很严重

![image-20251004155248028](https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/Java/202510041552091.png)

动态分区：每次根据算法划分一块内存（通常为 2 的幂），回收后合并相邻的空闲区，有外部碎片，缓解了内部碎片

| **算法**                  | **策略**                   | 优点         | 缺点                   |
| ------------------------- | -------------------------- | ------------ | ---------------------- |
| **首次适应（First Fit）** | 找到第一个足够大的空闲块   | 速度最快     | 外部碎片集中在前部     |
| **最佳适应（Best Fit）**  | 找最小的能满足要求的空闲块 | 内部碎片最少 | 外部碎片最多，速度最慢 |
| **最差适应（Worst Fit）** | 找最大的空闲块             | 外部碎片最少 | 内部碎片最多           |

![image-20251004154614410](https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/Java/202510041546482.png)

#### 非连续内存分配

段式管理：程序按逻辑结构划分为若干段，每段有独立的长度和基址

<img src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/Java/202510041550765.png" alt="image-20251004155035693" style="zoom:50%;" />

页式管理：内存与进程空间都划分成等长的页，通过页表实现虚拟页号到物理页号的映射

![image-20251004155050112](https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/Java/202510041550180.png)

### 虚拟内存

#### 定义

虚拟内存是一种内存管理技术，为每个进程提供了一个连续、统一的虚拟地址空间，由操作系统和 MMU 协同完成地址映射，使得程序在逻辑上拥有完整内存，而实际上只占用部分物理内存

- **简化管理**：每个进程看到的都是从 0x00000000 开始的连续虚拟地址空间，不再需要关心实际物理内存空间
- **隔离进程**：每个进程拥有独立虚拟地址空间，保证了一个进程无法访问另一个进程的内存，从而提升系统安全性与稳定性
- **按需调页**：程序运行时，不必一次性把所有代码和数据加载进内存，而是只在访问某页时才加载
- **共享内存**：虽然虚拟内存相互独立，但多个进程可以将部分虚拟页映射到同一物理页，实现高效的 IPC
- **页面置换**：当物理内存不足时，操作系统会根据算法将旧页面换出到磁盘，为新页面腾出空间，实现“无限”内存

<img src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/Java/202510041620883.png" alt="image-20251004162030794" style="zoom:50%;" />

#### 页表

**虚拟地址（Virtual Address）**：是进程和程序员看到的地址，是程序运行时使用的地址，是 CPU 访问的地址

**物理地址（Physical Address）**：是内存条上数据的真实存储位置，是最终通过硬件总线和内存控制器的地址

**MMU（Memory Management Unit, 内存管理单元）**：是 CPU 内部的硬件模块，负责根据页表把虚拟地址转换为物理地址

**页表（Page Table）**：是操作系统为每个进程维护的一个数据结构，位于内存中，保存了虚拟页号到物理页号到映射关系

**页表项（Page Table Entry, PTE）**：是页表中的一个条目，除了保存虚拟页号映射的物理页号，还保存了若干元信息

- P（Present）：0 表示在磁盘，1 表示在内存
- R/W（Read/Write）：0 表示只读，1 表示可读写
- U/S（User/Supervisor）：0 表示仅内核态可访问，1 表示内核态和用户态可访问
- A（Accessed）：0 表示该页没被访问过，1 表示该页被访问过
- D（Dirty）：0 表示该页没被修改过，1 表示该页被修改过

#### 分页机制









