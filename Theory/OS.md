# OS



## 内核

### 定义

**操作系统（Operating System, OS）是计算机系统中管理硬件与软件资源的系统软件，为用户和应用程序提供统一接口和运行环境，包含内核、系统库和系统工具**

- **抽象**：屏蔽硬件差异，为应用程序提供统一接口
- **管理**：高效利用 CPU、内存、IO 等硬件资源
- **隔离**：不同进程之间互不干扰，保证安全
- **共享**：让多个应用程序能够公平高效地使用资源

<img src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/Java/202510011945701.png" alt="image-20251001194553633" style="zoom:50%;" />

**内核（Kernel）是操作系统的核心部分，常驻于内存，负责直接管理 CPU、内存、I/O**

- **内核代码**：执行特权指令和特殊操作的代码，如系统调用、中断处理、异常处理等例程
- **内核数据**：保存系统运行时的全局状态信息，如进程控制块、页表、文件描述符表等
- **内核线程**：内核代码直接创建的线程，不依赖于任何进程，可以直接被调度器调度执行，负责处理内核的后台任务，如内存回收、日志写盘等

| **管理** | **负责**                                                     | **意义**                                     |
| -------- | ------------------------------------------------------------ | -------------------------------------------- |
| 进程管理 | 进程生命周期、进程间通信和同步，调度进程并发执行             | 让多任务安全高效地运行，保证系统公平和响应性 |
| 内存管理 | 内存分配和回收，提供虚拟内存，隔离不同进程的地址空间         | 提高内存利用率，保证进程之间互不干扰         |
| 文件管理 | 文件的创建、删除、读写和权限控制，提供统一的文件系统接口     | 让应用程序以统一方式访问数据，保障安全和共享 |
| 设备管理 | 把硬件设备抽象为设备文件，通过驱动程序实现 I/O 操作          | 屏蔽硬件差异，简化应用对设备的使用           |
| 网络管理 | 提供套接字接口，负责数据封装、传输和解包，实现主机间远程通信 | 让分布式应用和网络服务能够互联互通           |

### 用户态和内核态

用户态和内核态指的是 **CPU 的运行模式和权限等级（privilege level）**，而不是程序或进程的状态

| 维度     | 用户态                                 | 内核态                         |
| -------- | -------------------------------------- | ------------------------------ |
| 运行权限 | 低，只能访问用户内存，不能直接操作硬件 | 高，可以直接访问所有硬件和内存 |
| 运行对象 | 用户线程 / 用户代码                    | 内核线程 / 内核代码            |

CPU 要么运行在用户态，要么运行在内核态，这样做的原因是：

- **安全性**：限制应用程序，避免直接操作硬件
- **稳定性**：隔离应用程序和内核，应用崩溃只会影响自己，系统仍可以继续运行
- **可控性**：硬件只交给内核管理，所有特权指令由内核统一执行，

CPU 可以从用户态切换到内核态

- **系统调用（System Call）**：当应用程序需要执行受保护的操作时，可以主动通过系统调用，切换到内核中的特定例程执行，从而实现用户态 → 内核态
- **中断（Interrupt）**：当外部硬件完成用户请求的特权操作后，会主动向 CPU 发出中断信号，CPU 会暂停当前应用程序的执行，切换到内核中的中断服务程序执行，从而实现用户态 → 内核态
- **异常（Exception）**：当 CPU 在执行指令检测到错误的时候，会切换到内核中的异常处理程序执行，从而实现用户态 → 内核态
- **返回（Return）**：当系统调用 / 中断 / 异常处理完成后，CPU 会通过返回指令回到原来的执行点，从而实现内核态 → 用户态
- **调度（Schedule）**：当内核决定切换进程时，CPU 会保存当前进程的上下文并恢复新进程的上下文，从而实现内核态 → 用户态

### 系统调用

**特权指令（Privileged Instructions）**：内核态才能运行的 CPU 指令，用于执行敏感操作，如操作硬件和内存，可能会影响整个系统的安全

**Trap 指令**：是一类特殊的 CPU 指令，只有执行它才可以从用户态切换到内核态，并跳转到预定义的处理入口，常用于系统调用和异常处理

综上，当应用程序想要执行敏感操作时，必须先通过系统调用从用户态切换到内核态，然后**根据指定的系统调用号查找并跳转到对应的内核代码入口**。但需要注意的是，**执行内核代码的依然是应用程序自己的进程/线程**，并不存在一个专门的“内核进程”来帮你执行，也不是通过消息机制交给“内核线程”去处理

1. **应用程序调用库函数**：CPU 执行用户代码 `write(fd, buf, len)`
2. **触发 Trap 指令**：CPU 执行库函数底层指令 `syscall`
3. **进入内核态**：CPU 从用户态切到内核态，并跳转到内核的系统调用入口
4. **执行内核例程**：CPU 执行内核代码 `sys_write()`
5. **返回用户态**：CPU 执行 `iret` / `sysret` 切回用户态，继续执行应用程序后面的指令

