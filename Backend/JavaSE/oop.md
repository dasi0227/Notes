# OOP



   * [三大要素](#三大要素)
      * [封装](#封装)
      * [继承](#继承)
      * [重载与重写](#重载与重写)
      * [多态](#多态)
   * [Object 方法](#object-方法)
      * [equals](#equals)
      * [hashCode](#hashcode)
      * [getClass](#getclass)
      * [toString](#tostring)
   * [static](#static)
      * [类变量](#类变量)
      * [类方法](#类方法)
   * [codeblock](#codeblock)
      * [普通代码块](#普通代码块)
      * [构造代码块](#构造代码块)
      * [静态代码块](#静态代码块)
   * [加载顺序](#加载顺序)
      * [类加载时机](#类加载时机)
      * [static 和 codeblock](#static-和-codeblock)
      * [例子说明](#例子说明)
   * [特性](#特性)
      * [final](#final)
      * [abstract](#abstract)
   * [Inner Class](#inner-class)
      * [成员内部类](#成员内部类)
      * [静态内部类](#静态内部类)
      * [局部内部类](#局部内部类)
      * [匿名内部类](#匿名内部类)
   * [Interface](#interface)
      * [定义](#定义)
      * [implements](#implements)
      * [多态](#多态)
   * [单例设计模式](#单例设计模式)



## 三大要素

1. **封装（Encapsulation）**：把属性（数据）和方法（操作）封装在类的内部 ➡️ 将数据进行私有化，将方法公有化，通过方法对数据进行操作
2. **继承（Inheritance）**：让子类继承父类的特性 ➡️ 拥有父类公开的数据和方法，并且可以对父类的方法进行重写
3. **多态（Polymorphism）**：父类引用可以指向子类对象，调用的方法由对象的真实类型决定

### 封装

构造函数

- 不需要返回值，名字与类名一样
- 会自动创建一个默认构造函数，是没有参数的，一旦定义了自己的构造函数，则默认构造函数会被覆盖

访问修饰符

| 修饰符    | 同类 | 同包 | 子类 | 其他类/不同包 |
| --------- | ---- | ---- | ---- | ------------- |
| public    | ✅    | ✅    | ✅    | ✅             |
| protected | ✅    | ✅    | ✅    | ❌             |
| 默认      | ✅    | ✅    | ❌    | ❌             |
| private   | ✅    | ❌    | ❌    | ❌             |

this

- this 是引用，通过访问符 `.` 得到属性和方法，而 C++ 的 this 是指针，利用 `->`
- this() 可以在一个构造函数里面调用另一个构造函数，同时必须位于构造函数的第一行
- 可以发现，构造函数不能同时存在 this() 和 super()，因为它们都必须放在构造函数的第一行，会造成冲突

### 继承

父类和子类的关系

- **父类和子类并不是指直接继承，而是指全部上基类和当前类，查找的时候遵循就近原则**，往下所有讨论都符合这个原则
- 所有类都是 Object 类的子类
- 子类通过 extends 继承父类
- 子类只能继承 public 和 protected 的属性和方法
- 子类不会继承 private 的属性和方法，但是可以通过 public 和 protected 的方法获取和调用
- 类只能继承一个父类（儿子只能有一个爸爸），但是一个父类可以有多个子类（爸爸可以有多个儿子）
- 如果子类没有属性，就一直向上查找父类是否有属性，直到找到属性，否则报错

super

- 子类不会继承构造函数，但是子类的构造函数一定需要调用父类的构造函数
- 默认情况，子类会**隐式自动添加并调用 super()**，也就是调用父类的无参构造函数
- 如果父类写了有参构造函数，那么父类的无参构造函数则会被销毁/覆盖，如果同时父类没有提供无参构造函数，则子类会出错，因此必须显式调用 super(...) 调用指定构造函数
- super(...) 必须放在子类构造函数的第一行，因为必须先有父亲才有儿子
- super.method/attribute 可以显式指明调用父类的属性/方法而不是当前子类的，如果存在多个同名的成员，则遵循就近原则

### 重载与重写

重载（overload）：同一个类之间

- 方法名必须相同，返回值可以不同
- 参数列表必须不同：数量不同、类型不同、顺序不同
- 可变参数需要加上省略号，表示接收零到多个参数，此时可变参数当作数组，但是必须作为最后一个参数

重写（override）：父类和子类之间

- 方法名必须相同，返回值可以是父类的返回类型，也可以是父类返回类型的子类
- 参数列表必须完全相同
- 子类只能重写父类的 public 和 protected 方法，父类的构造函数、static 方法、private 方法都不能被重写
- 重写方法的访问级别不能低于父类的，也就是说 protected 可以重写为 public，默认可以重写为默认、protected、public

### 多态

多态；本质上是方法的动态绑定，也就是运行时才确定对象

- Animal animal = new Cat()：左边称为编译类型，右边称为运行类型
- 编译类型可以是运行类型的父类，这样 javac 不会报错
- 向上转型：子类 → 父类，父类引用可以指向子类对象
    - 可以调用父类中所有方法
    - 不能调用子类的独有方法
- 向下转型：父类 → 子类，可以把父类引用强制转化为子类对象
    - 不能转换父类的对象
    - 父类的引用必须指向要转移的对象
    - 转换后就可以调用子类的所有方法
- 属性是编译时绑定的，无法被重写，即使子类定义了同名字段，访问的仍是父类的字段，**哪怕运行的是子类的方法，但是属性的值依旧是父类的**

instanceof：用于判断某个对象类型是否为某类型或其子类型

- 配合向下转型使用，防止强制转换出错
- 左边必须是对象类型，不能是基本类型
- 判断的是运行类型，而不是编译类型



## Object 方法

> **Object 是所有类的父类，是最上级的类，所有类都继承了 Object 的方法**

### equals

用于自定义类的判断相等逻辑

- `==` 判断基本类型是值是否相等，判断引用类型是地址是否相等
- `equals()` 默认是判断地址是否相等
- 重写 `equals()` 通常用法是实现比较字段

### hashCode

返回对象的哈希值，用于哈希集合（如 HashMap、HashSet）

- 如果两个引用指向的是同一个对象，哈希值一定相同
- 如果两个对象内容相等但没重写 hashCode()，哈希值可能不同
- 哈希值 ≠ 地址，但常由地址或字段值计算得出
- 重写 `equals()` 时必须同时重写 `hashCode()`，这是为了 HashSet 的使用

### getClass

获取对象的运行时类，用于反射或类型判断

- 返回类型为 `Class<? extends Object>`
- 输出为 `class 包路径.类名 `

### toString

返回对象的字符串表示，默认格式为 ` 类名@哈希码 `

- 原型实现：`return getClass().getName() + "@" + Integer.toHexString(hashCode())`
- 哈希码是十六进制形式，值与 `hashCode()` 相同
- 直接打印对象时，会自动调用 `toString()`
- 实际开发中应重写该方法提供更有意义的输出（如展示字段值）



## static

> **static 声明的属性和方法，对于所有对象都是同一个地址，属于类本身而不属于任何对象**

### 类变量

- 定义方式可以是 ` 访问修饰符 static 数据类型 变量名 ` 或 `static 访问修饰符 数据类型 变量名 `

- 类变量可以通过类名调用，也可以通过对象调用，推荐前者，表示全体类的对象共享

- 类变量随着类创建而创建，哪怕没有实例/对象也可以访问

- 常用于：计数器、常量、缓存、共享状态等

### 类方法

- 定义方式为：` 访问修饰符 static 返回类型 方法名(参数列表)`

- 类方法可以通过类名调用，也可以通过对象调用

- 类方法**不能访问实例变量或实例方法**，只能访问其他 static 成员

- 类方法中不能使用 `this` 或 `super`，因为它不属于任何对象

- 常用于：不需要创建对象就可以使用的工具方法（如加法、格式化、计算等）



## codeblock

### 普通代码块

在方法内部，用来控制作用域、变量生命周期

```java
public void test() {
    {
        int x = 10;
        System.out.println(x);
    }
}
```

### 构造代码块

定义在类中、但不在任何方法里，在每次创建对象时都会执行一次，优先于构造函数执行

```java
  public class Demo {
      {   
      System.out.println("我是构造代码块");
      }
  
      public Demo() {
          System.out.println("我是构造函数");
      }
  }
```

### 静态代码块

在类加载时执行一次，整个类生命周期只执行一次，是最先执行的

```java
public class Demo {
    static {
        System.out.println("我是静态代码块");
    }
     public Demo() {
        System.out.println("我是构造函数");
    }
}
```



## 加载顺序

### 类加载时机

- 创建对象实例
- 创建子类对象实例
- 使用类的静态成员

### static 和 codeblock

- 如果只是使用静态成员，没有创建类的实例，构造函数不会执行，构造代码块也不会被执行
- 静态代码块和静态属性初始化的优先级是一样的，此时遵循先后顺序
- 普通代码块和普通属性初始化的优先级是一样的，此时遵循先后顺序
- 不管属性写在哪儿，JVM 都会先初始化属性，再执行构造方法
- 静态代码块只能调用静态成员，普通代码块可以调用任意成员

### 例子说明

1. 加载 Father 类
    1. 创建父类静态成员，执行父类静态方法
    2. 执行父类静态代码块
2. 加载 Child 类
    1. 执行子类静态代码块
    2. 创建子类静态成员，执行子类静态方法
3. 创建父类对象
    1. 执行父类构造代码块
    2. 执行父类构造函数
4. 创建子类对象
    1. 执行子类构造代码块
    2. 执行子类构造函数

```java
package study.OOP.codeblock;

class Father {
    public static int num = getNum();

    static {
        System.out.println("父类静态代码块");
    }

    {
        System.out.println("父类构造代码块");
    }

    public Father() {
        System.out.println("父类构造函数");
    }

    public static int getNum() {
        System.out.println("父类静态成员变量");
        return 10;
    }
}

class Child extends Father {
    static {
        System.out.println("子类静态代码块");
    }

    public static int num = getNum();

    {
        System.out.println("子类构造代码块");
    }

    public Child() {
        System.out.println("子类构造函数");
    }

    public static int getNum() {
        System.out.println("子类静态成员变量");
        return 10;
    }
}

public class CodeBlock2 {
    public static void main(String[] args) {
        Child c = new Child();
    }
}
```

```txt
父类静态成员变量
父类静态代码块
子类静态代码块
子类静态成员变量
父类构造代码块
父类构造函数
子类构造代码块
子类构造函数
```



## 特性

### final

final 标识运行期常量

- 修饰基本数据类型：值不可变
- 修饰引用类型变量：引用不能变，对象可以变
- 修饰方法：不能被重写
- 修饰类：不能被继承
- Java 的 `public static final` == C++ 的 `const`，是编译器常量

### abstract

abstract 强制要求所有子类都必须要完成抽象的实现

- 抽象类：**不能被实例化，但可以被继承**
- 抽象方法：**没有方法体，即没有 `{}`（不能说没有实现，因为空实现也算是有方法体），但是有返回值和参数列表**
- 没有抽象属性
- 抽象类可以没有抽象方法，也可以有普通方法
- 如果子类不是抽象类，并且要继承抽象父类，则必须重写实现它的所有抽象方法
- 如果子类是抽象类，则可以直接继承抽象父类
- 抽象方法不能用 private、final 和 static 修饰，否则就无法被重写，违背初衷



## Inner Class

> 内部类是定义在一个类的内部的类

### 成员内部类

- 可以添加访问修饰符

- 创建语法：Outer.Inner inner = outer.new Inner();
- 也可以单独写一个 get 函数获取成员内部类对象

```java
class Outer {
    class Inner {}
}
Outer outer = new Outer();
Outer.Inner inner = outer.new Inner();
```

### 静态内部类

- 可以添加访问修饰符

- 可以直接访问外部类的所有静态成员，但是不能直接访问非静态成员
- 外部其他类可以直接访问

```java
class Outer {
    static class Inner {}
}
Outer.Inner inner = new Ouert.Inner();
```

### 局部内部类

- 可以直接使用外部类的所有成员，包括 private，因为其所属的方法是属于外部类

- 局部内部类不能添加访问修饰符，因为其相当于局部变量
- 局部内部类可以用 final 修饰，也就是不能被其他内部类继承
- 外部类如果要访问局部内部类里面的方法，则在外部类的方法中创建局部内部类对象再调用
- 外部内部类不能直接创建局部内部类对象，必须通过方法创建
- 局部内部类和外部类的成员重名时，遵循就近原则，想访问外部类的成员方法为 ` 外部类名.this.成员名 `

```java
class Outer {
    void method() {
        class Inner {}
    }
}
```

### 匿名内部类

- 用一次就走，无需单独定义类，避免创建冗余类

- 快速实现接口/抽象类，特别适合事件处理、回调函数、策略注入等场景
- jdk 底层是定义了一个临时名的内部类，并 new 了一个实例返回，实际上可以通过 getClass 获取这个类名，但是无法使用它再创建对象
- 匿名内部类可以创建新方法，但外部对象无法使用，因为编译类型是没有该方法的，但是也可以使用其他极端方法利用

```java
class Outer {
    public void method() {
        System.out.println("Outer original");
    }
}
Outer outer = new Outer() {
    public void method() {
        System.out.println("Anonymous override");
    }
};
```



## Interface

### 定义

接口是一种特殊的引用类型，用 interface 定义，里面只能包含**抽象方法和常量**，用来规定**类必须实现的行为规范**

- 让不同类之间拥有相同的“能力外壳”，便于多态调用和代码解耦
- 接口是一种面向行为编程的契约机制，谁实现它，就必须兑现承诺，实现所有规定方法
- 所有方法都默认 `abstract public`：都是抽象方法
- 所有变量都默认 `public static final`：都是常量，因此可以用接口名去访问
- 接口的所有变量都必须在定义的时候就要赋值
- jdk8 之后可以有 static 方法和 default 方法
- 接口不能被实例化，因为它的作用是提供规范，而不是作为对象
- 接口的访问权限修饰符只能是 public 或 默认

### implements

- 如果非抽象类实现接口，那么必须实现其所有函数
- 抽象类实现接口，可以不用实现其所有函数
- 重写的方法必须是 public，因为原来的函数是 public，重写不能将访问限制升级，只能降级，而 public 是最低级
- 一个类可以同时实现多个接口，因为一个机器本来就是有多个接口，不像儿子只有一个爸爸
- 接口可以继承接口，而且还可以继承多个接口
- 接口不能继承类

| 比较项       | extends（继承）                | implements（实现接口）                        |
| ------------ | ------------------------------ | --------------------------------------------- |
| 作用对象     | 类（子类 → 父类）              | 接口（类 → 接口）                             |
| 设计目标     | 复用代码，表示“是什么”         | 规范行为，表示“能做什么”                      |
| 目标类型     | 继承一个类（只能一个）         | 实现一个或多个接口（支持多个）                |
| 重写方法     | 父类可能已提供实现             | 必须实现接口中所有抽象方法                    |
| 可继承内容   | 方法、属性、构造器             | 方法签名                                      |
| 是否有构造器 | 父类有构造器可被调用           | 接口不能有构造器                              |
| 访问权限     | 受限于继承关系，允许 protected | 接口方法默认是 public                         |
| 场景示例     | `class Dog extends Animal`     | `class Dog implements Runnable, Serializable` |

### 多态

**父接口的引用可以指向任何实现了该接口的类对象**：` 接口名 变量名 = new 实现类名();`

- 多态的本质（与类是一样的）：编译看左边，运行看右边
- 多态调用只能调用接口有的方法，不能调用类特有的方法
- 如果想调用类特有的方法，需要进行强制类型转换 `((类名)变量名).方法 `，注意 `.` 运算符优先级高，因此需要还需要一个括号
- 多态传递：如果接口 A 继承了接口 B，那么类只要实现 A，也相当于实现了 B（因为必须实现接口 A 和接口 B 的所有方法）

调用关系：`class C extends B implements A{}`

- 如果 A、B、C 都有同名变量 x
    - C 使用 C：直接 x 或 this.x
    - C 使用 B：super.x
    - C 使用 A：A.x
- 如果 A、B 都有同名方法 f
    - C 重写了 f，那么就调用自己的重写的方法
    - C 没有重写 f，那么就调用 B 的方法
    - 即使 B 在定义 f 时并没有显式说明是为了实现 A ，但是 C 继承 B 也会继承同名方法 f，相当于 B 间接地帮 C 实现了接口方法的实现



## 单例设计模式

确保一个类在整个程序中只有一个实例，并提供全局访问点来获取这个实例

- 获取实例的方法必须是静态的，因为此时根本没有对象，所以只能通过类名调用方法
- 内部实例也必须是静态的，因为无法手动创建对象，如果不是静态就永远不会有内部实例
- 构造函数必须是 private，禁止外部一切构造，只能使用内部的唯一实例
- 饿汉式：类加载时就创建一个内部静态实例，然后通过一个静态方法返回唯一的实例 ➡️ 哪怕这个实例没用到也初始化了，占用内存
- 懒汉式：类在使用时才创建创建一个内部静态实例，然后通过一个静态方法返回唯一的实例 ➡️ 存在并发风险，必须锁同步