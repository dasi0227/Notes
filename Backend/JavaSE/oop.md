# OOP

面向对象编程三要素
1. 封装（Encapsulation）：把属性（数据）和方法（操作）封装在类的内部 ➡️ 将数据进行私有化，将方法公有化，通过方法对数据进行操作
2. 继承（Inheritance）：让子类继承父类的特性 ➡️ 拥有父类公开的数据和方法，并且可以对父类的方法进行重写
3. 多态（Polymorphism）：父类引用可以指向子类对象，调用的方法由对象的真实类型决定

面向对象编程五大成员
1. 成员变量
2. 成语函数
3. 构造函数
4. 代码块
5. 内部类

## 访问修饰符

| 修饰符      | 同类 | 同包 | 子类 | 其他类/不同包 |
|----------|----|----|----|---------|
| public   | ✅  | ✅  | ✅  | ✅       |
| protected | ✅  | ✅  | ✅  | ❌       |
| 默认       | ✅  | ✅  | ❌  | ❌       |
| private  | ✅  | ❌  | ❌  | ❌       |

## 构造函数

构造函数:
- 不需要返回值，名字与类名一样
- 会自动创建一个默认构造函数，是没有参数的，一旦定义了自己的构造函数，则默认构造函数会被覆盖

## 继承

- **父类和子类并不是指直接继承，而是指全部上基类和当前类，查找的时候遵循就近原则**，往下所有讨论都符合这个原则
- 所有类都是 Object 类的子类
- 子类通过 extends 继承父类
- 子类只能继承 public 和 protected 的属性和方法
- 子类不会继承 private 的属性和方法，但是可以通过 public 和 protected 的方法获取和调用
- 类只能继承一个父类（儿子只能有一个爸爸），但是一个父类可以有多个子类（爸爸可以有多个儿子）
- 如果子类没有属性，就一直向上查找父类是否有属性，直到找到属性，否则报错

## super

- 子类不会继承构造函数，但是子类的构造函数一定需要调用父类的构造函数
- 默认情况，子类会**隐式自动添加并调用 super()**，也就是调用父类的无参构造函数
- 如果父类写了有参构造函数，那么父类的无参构造函数则会被销毁/覆盖，如果同时父类没有提供无参构造函数，则子类会出错，因此必须显式调用 super(...) 调用指定构造函数
- super(...) 必须放在子类构造函数的第一行，因为必须先有父亲才有儿子
- super.method/attribute 可以显式指明调用父类的属性/方法而不是当前子类的，如果存在多个同名的成员，则遵循就近原则

## this

- this 是引用，通过访问符 `.` 得到属性和方法，而 C++ 的this 是指针，利用 `->`
- this() 可以在一个构造函数里面调用另一个构造函数，同时必须位于构造函数的第一行
- 可以发现，构造函数不能同时存在 this() 和 super()，因为它们都必须放在构造函数的第一行，会造成冲突

## overload & override

重载（overload）：同一个类之间
- 方法名必须相同，返回值可以不同
- 参数列表必须不同：数量不同、类型不同、顺序不同
- 可变参数需要加上省略号，表示接收零到多个参数，此时可变参数当作数组，但是必须作为最后一个参数

重写（override）：父类和子类之间
- 方法名必须相同，返回值可以是父类的返回类型，也可以是父类返回类型的子类
- 参数列表必须完全相同
- 子类只能重写父类的 public 和 protected 方法，父类的构造函数、static 方法、private 方法都不能被重写
- 重写方法的访问级别不能低于父类的，也就是说 protected 可以重写为 public，默认可以重写为默认、protected、public

## 多态

多态；本质上是方法的动态绑定，也就是运行时才确定对象
- Animal animal = new Cat()：左边称为编译类型，右边称为运行类型
- 编译类型可以是运行类型的父类，这样 javac 不会报错
- 向上转型：子类 → 父类，父类引用可以指向子类对象
	- 可以调用父类中所有方法
	- 不能调用子类的独有方法
- 向下转型：父类 → 子类，可以把父类引用强制转化为子类对象
	- 不能转换父类的对象
	- 父类的引用必须指向要转移的对象
	- 转换后就可以调用子类的所有方法
- 属性是编译时绑定的，无法被重写，即使子类定义了同名字段，访问的仍是父类的字段，**哪怕运行的是子类的方法，但是属性的值依旧是父类的**

instanceof：用于判断某个对象类型是否为某类型或其子类型
- 配合向下转型使用，防止强制转换出错
- 左边必须是对象类型，不能是基本类型
- 判断的是运行类型，而不是编译类型

## Object

- Object.equals(Object obj)：用于自定义类的判断相等逻辑
	- `==` 判断基本类型是值是否相等，判断引用类型是地址是否相等
	- `equals()` 默认是判断地址是否相等
	- 重写 `equals()` 通常用法是实现比较字段

- Object.hashCode()：返回对象的哈希值，用于哈希集合（如 HashMap、HashSet）
	- 如果两个引用指向的是同一个对象，哈希值一定相同
	- 如果两个对象内容相等但没重写 hashCode()，哈希值可能不同
	- 哈希值 ≠ 地址，但常由地址或字段值计算得出
	- 重写 `equals()` 时必须同时重写 `hashCode()`，这是为了 HashSet 的使用

- Object.getClass()：获取对象的运行时类，用于反射或类型判断
	- 返回类型为 `Class<? extends Object>`
	- 输出为 `class 包路径.类名`

- Object.toString()：返回对象的字符串表示，默认格式为 `类名@哈希码`
	- 原型实现：`return getClass().getName() + "@" + Integer.toHexString(hashCode())`
	- 哈希码是十六进制形式，值与 `hashCode()` 相同
	- 直接打印对象时，会自动调用 `toString()`
	- 实际开发中应重写该方法提供更有意义的输出（如展示字段值）

## static

static 声明的属性和方法，对于所有对象都是同一个地址（属于类，不属于对象）

类变量
- 定义方式可以是 `访问修饰符 static 数据类型 变量名` 或 `static 访问修饰符 数据类型 变量名`
- 类变量可以通过类名调用，也可以通过对象调用，推荐前者，表示全体类的对象共享
- 类变量随着类创建而创建，哪怕没有实例/对象也可以访问
- 常用于：计数器、常量、缓存、共享状态等

类方法
- 定义方式为：`访问修饰符 static 返回类型 方法名(参数列表)`
- 类方法可以通过类名调用，也可以通过对象调用
- 类方法**不能访问实例变量或实例方法**，只能访问其他 static 成员
- 类方法中不能使用 `this` 或 `super`，因为它不属于任何对象
- 常用于：不需要创建对象就可以使用的工具方法（如加法、格式化、计算等）

## codeblock

- 普通代码块：在方法内部，用来控制作用域、变量生命周期
    ```java
    public void test() {
        {
            int x = 10;
            System.out.println(x);
        }
    }
    ```
- 构造代码块：定义在类中、但不在任何方法里，在每次创建对象时都会执行一次，优先于构造函数执行
  ```java
    public class Demo {
        {   
        System.out.println("我是构造代码块");
        }
    
        public Demo() {
            System.out.println("我是构造函数");
        }
    }
    ```
- 静态代码块：在类加载时执行一次，整个类生命周期只执行一次，是最先执行的
    ```java
    public class Demo {
        static {
            System.out.println("我是静态代码块");
        }
         public Demo() {
            System.out.println("我是构造函数");
        }
    }
    ```

## 顺序

类什么时候被加载：
- 创建对象实例
- 创建子类对象实例
- 使用类的静态成员

static 和 codeblock
- 如果只是使用静态成员，没有创建类的实例，构造函数不会执行，构造代码块也不会被执行
- 静态代码块和静态属性初始化的优先级是一样的，此时遵循先后顺序
- 普通代码块和普通属性初始化的优先级是一样的，此时遵循先后顺序
- 不管属性写在哪儿，JVM 都会先初始化属性，再执行构造方法
- 静态代码块只能调用静态成员，普通代码块可以调用任意成员

```java
package study.OOP.codeblock;

class Father {
    public static int num = getNum();

    static {
        System.out.println("父类静态代码块");
    }

    {
        System.out.println("父类构造代码块");
    }

    public Father() {
        System.out.println("父类构造函数");
    }

    public static int getNum() {
        System.out.println("父类静态成员变量");
        return 10;
    }
}

class Child extends Father {
    static {
        System.out.println("子类静态代码块");
    }

    public static int num = getNum();

    {
        System.out.println("子类构造代码块");
    }

    public Child() {
        System.out.println("子类构造函数");
    }

    public static int getNum() {
        System.out.println("子类静态成员变量");
        return 10;
    }
}

public class CodeBlock2 {
    public static void main(String[] args) {
        Child c = new Child();
    }
}
```

```txt
父类静态成员变量
父类静态代码块
子类静态代码块
子类静态成员变量
父类构造代码块
父类构造函数
子类构造代码块
子类构造函数
```

执行顺序
1. 加载 Father 类
	1. 创建父类静态成员，执行父类静态方法
	2. 执行父类静态代码块
2. 加载 Child 类
	1. 执行子类静态代码块
	2. 创建子类静态成员，执行子类静态方法
3. 创建父类对象
	1. 执行父类构造代码块
	2. 执行父类构造函数
4. 创建子类对象
	1. 执行子类构造代码块
	2. 执行子类构造函数

## 单例设计模式

确保一个类在整个程序中只有一个实例，并提供全局访问点来获取这个实例
- 获取实例的方法必须是静态的，因为此时根本没有对象，所以只能通过类名调用方法
- 内部实例也必须是静态的，因为无法手动创建对象，如果不是静态就永远不会有内部实例
- 构造函数必须是 private，禁止外部一切构造，只能使用内部的唯一实例
- 饿汉式：类加载时就创建一个内部静态实例，然后通过一个静态方法返回唯一的实例 ➡️ 哪怕这个实例没用到也初始化了，占用内存
- 懒汉式：类在使用时才创建创建一个内部静态实例，然后通过一个静态方法返回唯一的实例 ➡️ 存在并发风险，必须锁同步

## final

final：运行期常量
- 修饰基本数据类型：值不可变
- 修饰引用类型变量：引用不能变，对象可以变
- 修饰方法：不能被重写
- 修饰类：不能被继承
- Java 的 `public static final` == C++ 的 `const`，是编译器常量

## abstract

abstract：强制要求所有子类都必须要完成抽象的实现
- 抽象类：**不能被实例化，但可以被继承**
- 抽象方法：**没有方法体，即没有 `{}`（不能说没有实现，因为空实现也算是有方法体），但是有返回值和参数列表**
- 没有抽象属性
- 抽象类可以没有抽象方法，也可以有普通方法
- 如果子类不是抽象类，并且要继承抽象父类，则必须重写实现它的所有抽象方法
- 如果子类是抽象类，则可以直接继承抽象父类
- 抽象方法不能用 private、final 和 static 修饰，否则就无法被重写，违背初衷

## Inner Class

内部类是定义在另一个类的内部的类
- 成员内部类
    ```java
    class Outer {
        class Inner {}
    }
    Outer outer = new Outer();
    Outer.Inner inner = outer.new Inner();
    ```
- 静态内部类
    ```java
    class Outer {
        static class Inner {}
    }
    Outer.Inner inner = new Ouert.Inner();
    ```
- 局部内部类
    ```java
    class Outer {
        void method() {
            class Inner {}
        }
    }
    ```
- 匿名内部类
    ```java
    class Outer {
        public void method() {
            System.out.println("Outer original");
        }
    }
    Outer outer = new Outer() {
        public void method() {
            System.out.println("Anonymous override");
        }
    };
    ```

成员内部类
- 可以添加访问修饰符
- 注意语法：Outer.Inner inner = outer.new Inner();
- 或者单独写一个 get 函数获取成员内部类对象

静态内部类
- 可以添加访问修饰符
- 可以直接访问外部类的所有静态成员，但是不能直接访问非静态成员
- 外部其他类可以

局部内部类
- 可以直接使用外部类的所有成员，包括 private，因为其所属的方法是属于外部类
- 局部内部类不能添加访问修饰符，因为其相当于局部变量
- 局部内部类可以用 final 修饰，也就是不能被其他内部类继承
- 外部类如果要访问局部内部类里面的方法，则在外部类的方法中创建局部内部类对象再调用
- 外部内部类不能直接创建局部内部类对象，必须通过方法创建
- 局部内部类和外部类的成员重名时，遵循就近原则，想访问外部类的成员方法为 `外部类名.this.成员名`

匿名内部类：有时候某个抽象的方法或接口不一定需要永久实现，而是给某一个对象特殊且临时的实现，对其他对象没有影响
- 用一次就走，无需单独定义类，避免创建冗余类
- 快速实现接口/抽象类，特别适合事件处理、回调函数、策略注入等场景
- jdk 底层是定义了一个临时名的内部类，并 new 了一个实例返回，实际上可以通过 getClass 获取这个类名，但是无法使用它再创建对象
- 匿名内部类可以创建新方法，但外部对象无法使用，因为编译类型是没有该方法的，但是也可以使用其他极端方法利用（之后学）
