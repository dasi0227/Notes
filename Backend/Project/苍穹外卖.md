# 苍穹外卖



   * [项目设计](#项目设计)
      * [产品设计](#产品设计)
      * [前端设计](#前端设计)
      * [后端设计](#后端设计)
   * [代码设计](#代码设计)
      * [common](#common)
         * [constant](#constant)
         * [context](#context)
         * [enumeration](#enumeration)
         * [exception](#exception)
         * [json](#json)
         * [properties](#properties)
         * [result](#result)
         * [utils](#utils)
      * [pojo](#pojo)
         * [dto / vo](#dto-vo)
         * [entity](#entity)
      * [server](#server)
         * [annotation](#annotation)
         * [aspect](#aspect)
         * [handler](#handler)
         * [interceptor](#interceptor)
         * [config](#config)
         * [controller](#controller)
         * [service](#service)
         * [mapper](#mapper)
         * [SkyApplication](#skyapplication)
   * [业务处理](#业务处理)
      * [哈希处理](#哈希处理)
      * [删除处理](#删除处理)
      * [插入处理](#插入处理)
      * [更新/查询处理](#更新查询处理)
      * [日期处理](#日期处理)
   * [知识亮点](#知识亮点)
      * [Nginx](#nginx)
      * [RESTful](#restful)
      * [PageHelper](#pagehelper)
      * [SLF4J](#slf4j)
      * [JWT](#jwt)
         * [原理分析](#原理分析)
         * [代码分析](#代码分析)
         * [使用分析](#使用分析)
      * [Swagger](#swagger)
      * [OSS](#oss)
      * [@AutoFill](#autofill)
      * [@ExceptionHandler](#exceptionhandler)
      * [HttpClient](#httpclient)
      * [SpringCache](#springcache)
      * [SpringTask](#springtask)
      * [WebSocket](#websocket)
      * [ECharts/POI](#echartspoi)



## 项目设计

### 产品设计

从整体来看，最突出就是产品实现了**两个前端，一个提供给用户点单下单的客户端，一个提供给商铺设置菜品和查看营业数据的管理端**，而它们都发送请求到同一个后端。

实际上，它们的请求处理方式存在很多逻辑重合之处，因此**对同个后端发起请求可以很好地复用业务层和持久层代码，只需要按照需求获取不同的返回内容和对应格式**。

在我看来，这样**双端设计的本质是把对持久层的控制进行区分**。比如说对菜品/套餐/分类的添加/删除/编辑显然是管理端才能做的，而对订单/地址/购物车的添加/删除/编辑相关显然是客户端才能做的，但管理端和客户端都可以查询一定范围内的订单和菜品。除此之外，管理端对订单的处理只包括接受、拒绝、完成和取消，而客户端对订单的处理只包括创建、取消和催促。也就是说，**双端设计不仅可以粗粒度地划分不同端能处理的表，还能细粒度地划分不同端对相同表的处理操作**。

| **端**                  | **面向人群**   | **主要功能**                 | **交互方式** |
| ----------------------- | -------------- | ---------------------------- | ------------ |
| **A 端，Administration** | 开发者、管理员 | 版本升级、系统监控、合规监管 | PC           |
| **B 端，Business**       | 企业用户、商户 | 商品管理、订单管理、财务管理 | Web          |
| **C 端，Customer**       | 个人用户       | 浏览商品、订单支付、注册登录 | 小程序、APP  |

### 前端设计

经典的后台管理系统布局

- **左侧导航栏**：纵向集成多功能模块，支持一键快速切换
- **右侧内容区**：展示统计图表、数据表格和增删改查按钮
- **顶部工具栏**：展示系统信息、用户信息和全局信息

### 后端设计

基于 SpringBoot 框架的经典三层架构

- Controller 层：接收请求、参数校验、返回统一结果
- Service 层：封装业务逻辑、进行事物管理
- Mapper 层：数据库操作
- 集成 Spring 功能：全局拦截器、全局异常处理、日志处理、切面逻辑



## 代码设计

### common

#### constant

定义常量类，利用 `public static final` 的方式**将常量封装到类并进行语义化区分**，其中最主要的就是 `MessageConstant`，封装了遇到错误时返回给前端的提示信息常量。

```java
public class MessageConstant {
    public static final String PASSWORD_ERROR = "密码错误";
    public static final String ACCOUNT_NOT_FOUND = "账号不存在";
    public static final String ACCOUNT_LOCKED = "账号被锁定";
    public static final String ALREADY_EXISTS = "已存在";
    public static final String UNKNOWN_ERROR = "未知错误";
  	// ...
}
```

#### context

定义上下文类，这里主要就是一个 `IdContext` 类，包含一个静态线程本地变量，普通的 static 变量是所有线程共享的，但是 ThreadLocal 的内部机制是 **JDK 在每个线程对象里都维护了一个 ThreadLocalMap，这个 Map 的 key 是线程实例，value 就是存的值**。

在 Web 应用里，请求是通过线程池分发到不同线程执行的，也就是说**即使每个线程调用相同的 `threadLocal.get()/threadLocal.set(Id)`，也只会设置/获取各自的数据，本质上是利用线程的独立性实现了数据隔离**。

这样做的最大好处就在于一个线程对应一个请求，**在请求域的任何时间和任何地方，都可以随时设置/获取值**，不再需要一层一层地传递，巧妙地**借助线程将数据按照不同请求实现自动隔离，从而可以同时处理多个请求且不会造成数据覆盖**。

```java
public class IdContext {
    public static ThreadLocal<Long> threadLocal = new ThreadLocal<>();
    public static void setCurrentId(Long id) {
        threadLocal.set(id);
    }
    public static Long getCurrentId() {
        return threadLocal.get();
    }
    public static void removeCurrentId() {
        threadLocal.remove();
    }
}
```

#### enumeration

| 类型       | 优势                           | 适用于                   | 例子                                                         |
| ---------- | ------------------------------ | ------------------------ | ------------------------------------------------------------ |
| final 常量 | 轻量，**编译期转换**，直接使用 | 数值和字符串等单一固定值 | Double PI = 3.14159，Integer MAX_SIZE = 100，String MSG = "Hello world" |
| enum 枚举  | **类型安全**，语义明确         | 有限集合内的标识或状态   | {UPDATE, INSERT, SELECT, DELETE}                             |

```java
public static final int INSERT = 1;
public static final int UPDATE = 2;
public void doOp(int op) { ... }
doOp(INSERT);	// 合法，语义清晰
doOp(1);   		// 合法，但语义不清晰
doOp(999); 		// 合法，但运行时会出错
// --------------------------------------------
public enum OperationType {
    INSERT, UPDATE
}
public void doOp(OperationType op) { ... }
doOp(OperationType.INSERT); // 合法，语义清晰
doOp(999);                  // 不合法，编译直接报错
```

#### exception

定义异常类，这里的关键在于定义了一个 BaseException 继承自 RuntimeException，然后再自定义其他业务异常继承自 BaseException，这样做的好处有三个：

- BaseException 继承自 RuntimeException 表示**它是运行异常，不需要在方法签名上显式 throws，调用方也不强制捕获，而且可以在任何地方抛出，编译期间不会报错，在运行时才报错**。
- BaseException 作为“中介”，本质上是为了实现**异常隔离**，开发中可能只想为业务异常进行特殊处理，而对 RuntimeException 的其他子类进行其他处理，**因此通过捕获 BaseException 就可以只处理其和其子类**。
- **扩展性更好**，所有业务处理都直接继承自 BaseException，以后想要给所有业务异常加一个字段，只需要改 BaseException，子类自动继承。

```java
public class BaseException extends RuntimeException {
    public BaseException() {}
    public BaseException(String msg) { super(msg); }
}
public class PasswordErrorException extends BaseException {
    public PasswordErrorException() {}
    public PasswordErrorException(String msg) { super(msg); }
}
public class SetmealEnableFailedException extends BaseException {
    public SetmealEnableFailedException(){}
    public SetmealEnableFailedException(String msg){ super(msg); }
}
// ...
```

#### json

定义 ObjectMapper 的继承类，用来设置前端 JSON 数据和后端 Java 对象属性值之间的转换规则，**利用 super() 相当于是对默认 ObjectMapper 进行增强**，用于之后给 SpringMVC 使用的消息转换器拓展功能，这里不做过多赘述。

```java
public class JacksonObjectMapper extends ObjectMapper {
    // 默认的日期格式：示例 2025-08-16
    public static final String DEFAULT_DATE_FORMAT = "yyyy-MM-dd";
    // 默认的日期时间格式：示例 2025-08-16 14:30
    public static final String DEFAULT_DATE_TIME_FORMAT = "yyyy-MM-dd HH:mm";
    // 默认的时间格式：示例 14:30:59
    public static final String DEFAULT_TIME_FORMAT = "HH:mm:ss";
		// 
    public JacksonObjectMapper() {
        super();
        // 当前端传来的 JSON 字段在后端 Java 类里没有对应属性时，不要抛出异常，而是忽略它
        this.configure(FAIL_ON_UNKNOWN_PROPERTIES, false);
      	this.getDeserializationConfig()
          	.withoutFeatures(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);
        // 注册自定义时间格式的序列化器和反序列化器（篇幅受限，这里的传参就不写了，不是重点）
        SimpleModule simpleModule = new SimpleModule()
        		// 反序列化器：把 JSON 字符串转为 Java 对象
            .addDeserializer(LocalDateTime.class, new LocalDateTimeDeserializer(...))
            .addDeserializer(LocalDate.class, new LocalDateDeserializer(...))
            .addDeserializer(LocalTime.class, new LocalTimeDeserializer(...))
            // 序列化器：把 Java 对象转为 JSON 字符串
            .addSerializer(LocalDateTime.class, new LocalDateTimeSerializer(...))
            .addSerializer(LocalDate.class, new LocalDateSerializer(...))
            .addSerializer(LocalTime.class, new LocalTimeSerializer(...));
        // 将自定义的模块注册到 ObjectMapper 中
        this.registerModule(simpleModule);
    }
}
```

#### properties

本质上是**利用 Java 类来承载 application.yml 配置文件中的数据**，通常需要以下三个注解

- **@Component**：注册为 Bean，把对象交给 Spring 管理，从而在其他地方可以直接注入来获取配置值。
- **@ConfigurationProperties(prefix = "...")**：指定配置文件中的映射，Spring 会自动把对应前缀下的配置项按照名称批量注入到类的属性之中。
- **@Data**：自动生成 Getter/Setter、toString、equals、hashCode，通常用来注解只有属性没有方法的类。

```java
@Component
@ConfigurationProperties(prefix = "sky.alioss")
@Data
public class AliOssProperties {
    private String endpoint;
    private String accessKeyId;
    private String accessKeySecret;
    private String bucketName;
}
```

#### result

定义统一的返回结果类 Result，通常需要包括业务响应码 code（不是 HTTP 状态码），业务响应信息 msg 和业务响应数据 data，同时需要实现 Serializable，这是因为：

- 当对象需要通过网络、消息队列和 RPC 等方式传输的时候，必须具备可序列化特性。
- 当需要把返回结果写入 Redis、Ehcache 等缓存时，Java 原生序列化要求对象必须实现 Serializable。

```java
@Data
public class Result<T> implements Serializable {
    private Integer code; 	// 业务码：1 成功，0 和其它数字为失败
    private String msg;			// 业务信息：错误信息或提示信息
    private T data; 				// 业务数据

  	// 不需要返回数据的成功响应结果
    public static <T> Result<T> success() {
        Result<T> result = new Result<T>();
        result.code = 1;
        return result;
    }
  	// 需要返回数据的成功响应结果
    public static <T> Result<T> success(T object) {
        Result<T> result = new Result<T>();
        result.data = object;
        result.code = 1;
        return result;
    }
  	// 需要返回信息的失败响应结果
    public static <T> Result<T> error(String msg) {
        Result result = new Result();
        result.msg = msg;
        result.code = 0;
        return result;
    }
}
```

#### utils

提供了一些工具类，通常以 public static 方法为主，或者注册为 Bean 给容器

- 封装一些通用方法，避免出现大量重复代码：加密、格式化
- 封装一些专用方法，与业务逻辑解耦：支付、文件上云

这里有一个需要注意的地方，那就是**像阿里云 OSS 这类的第三方服务工具，适合用 @Configuration + @Bean 的方式来注册 Bean，而不是直接声明为 @Component**。这是因为如果直接写成 @Component，它就是一个“固定的 Bean”，Spring 扫描后会立刻注册，无法根据条件灵活替换，而用 @Configuration + @Bean 的方式，则可以在方法里读取配置属性，实现**选择性装配和条件化注册**，从而自主切换不同厂商提供的服务。

```java
@Configuration
public class OssConfig {
    @Bean
    @ConditionalOnProperty(name = "oss.type", havingValue = "aliyun")
    public AliOssUtil aliOssUtil(AliOssProperties props) {
        return new AliOssUtil(
            props.getEndpoint(),
            props.getAccessKeyId(),
            props.getAccessKeySecret(),
            props.getBucketName()
        );
    }
  
    @Bean
    @ConditionalOnProperty(name = "oss.type", havingValue = "tencent")
    public CosUtil cosUtil(CosProperties props) {
        return new CosUtil(...);
    }
}
```

### pojo

#### dto / vo

**DTO（Data Transfer Object）**是用来承载前端传过来的请求体数据，属性名必须与 JSON 键值完全一致，这样只需要在控制方法的参数标上 @RequestBody 注解，底层 Jackson 就可以实现反序列化和自动映射。

**VO（View Object）**是用来承载返回给前端的响应体数据，属性名必须与 JSON 键值完全一致，这样只需要在控制方法的参数标上 @ResponseBody 注解，底层 Jackson 就可以实现序列化和自动映射。

```java
public class EmployeeDTO implements Serializable {
    private Long id;
    private String username;
    private String name;
    private String phone;
    private String sex;
    private String idNumber;
}
// --------------------------------------------------------
public class EmployeeLoginVO implements Serializable {
    private Long id;
    private String userName;
    private String name;
    private String token;
}
```

#### entity

实体类，本质上就是数据库表一一对应的 Java 对象，类中的属性名（驼峰式）通常与数据库表的字段名完全对应（下划线），通常来说，一个实体类就对应一个数据库表，也对应一个 Mapper 类，通常需要以下三个注解：

- **@Data**：提供 getter、setter，用于快速按需填充字段。
- **@Builder**：避免构造器参数填充过多或者反复多次调用 setter，让对象创建更清晰
- **@NoArgsConstructor**：MyBatis 等 ORM 框架会反射调用无参构造器来创建对象。

```java
public class Employee implements Serializable {
    private static final long serialVersionUID = 1L;
    private Long id;
    private String username;
    private String name;
    private String password;
    private String phone;
    private String sex;
    private String idNumber;
    private Integer status;
    private LocalDateTime createTime;
    private LocalDateTime updateTime;
    private Long createUser;
    private Long updateUser;
}
```

### server

#### annotation

设置自定义注解，该项目只创建了[@AutoFill](#@AutoFill)，实际上自定义注解通常有以下三个作用：

- **元数据标记**：给类、方法、字段添加标识，不需要逻辑，只是提供信息提示给编译器或框架，如 @Override、@Deprecated。
- **配置驱动**：作为配置方式代替 XML，被 Spring 容器解析，如 @Autowired、@RequestMapping、@TableName。
- **作为切入点**：可以标记到任意方法，并且可以添加到切入点表达式，从而更加灵活地设置切面逻辑。

#### aspect

设置切面类，通常具有以下三个步骤

1. 利用 **@Aspect** 和 **@Component** 声明并注册一个切面，交给 Spring 容器自动执行。
2. 利用 **@Pointcut** 设置一个通用的切入点表达式，从而在不同通知中复用。
3. 利用 **@Before**、**@After** 等设置通知逻辑，通过 **JoinPoint** 获取到切入点信息，最后利用反射完成切面织入。

#### handler

设置异常处理类，通常具有以下两个步骤：

1. 在类上注解 **@RestControllerAdvice**：标识这是一个 REST 风格的全局异常处理类，相当于是 **@ControllerAdvice + @ResponseBody** 的结合体，其中 Controller 的含义是对控制器进行增强，这是因为下层抛出的异常会一直向上传递到 Controller。
2. 在方法上注解 **@ExceptionHandler**：标识这是一个异常处理方法，在方法的参数列表里，直接写上要捕获的异常类型，就可以获取到异常对象。

#### interceptor

设置拦截器类，需要**实现 HandlerInterceptor 接口**，然后在 SpringMVC 的配置类中**注册拦截器到 InterceptorRegistry 中**，一般会重写以下三个方法：

| 方法            | 时机                                                         | 功能                                                         |
| --------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| preHandle       | 请求到达 Controller 之前                                     | 对前端数据进行初步校验，返回 true 则进入控制层，返回 false 会中断请求 |
| postHandle      | Controller 执行完，视图渲染/消息转换前，此时还没有写入到响应体 | 对 Controller 的返回结果进行处理                             |
| afterCompletion | 请求完成（包括异常处理），此时已经把数据写到响应体           | 对资源进行清理以及日志输出                                   |

而这些方法具有以下固定参数

- **HttpServletRequest request**：请求报文对象
- **HttpServletResponse response**：响应报文对象
- **Object handler**：即将要执行的目标处理器对象，如果是控制器方法，那么它就属于 **HandlerMethod** 类型

>  ModelAndView modelAndView 是只在 postHandle 方法中有，代表控制器返回的视图模型对象，当且仅当返回视图渲染结果时 Spring 才会自动注入

#### config

设置配置类，需要带有 **@Configuration** 注解，其中主要有两种方式完成配置：

- **@Bean**：Spring 会把 @Bean 注解的方法的返回对象注册到容器，通常用于第三方类，这是因为**我们无法在源码上加 @Component 注册为 Bean，只能通过 `return new XXX();` 完成注册**。
- **重写方法**：通过继承特定类或实现特定接口，可以扩展和修改 Spring 框架的默认行为。

#### controller

设置控制层类，通常具有以下三个步骤：

1. 在类上注解 **@RestController(value = "xxx")**：标识这是一个 REST 风格的控制器类，相当于是 **@Controller + @ResponseBody** 的结合体，value 属性是用于标识 Bean 名称，因为默认情况下是类名，但是**如果存在多个模块有相同的类名，那么 Spring 就无法处理，这时就需要显式指定 Bean 的名称。**
2. 在类上注解 **@RequestMapping(value = "xxx")**：定义给类所有接口的**统一路径前缀。**
3. 在方法上注解 **@XXXMapping(value = "")**：定义某个具体接口的**路径和 HTTP 方法。**

#### service

设置业务类，这里没有什么好说的，最需要注意的就是，**@Service 注解是放在实现类而不是接口类上的，但是注入的时候是使用接口类型**

- **Spring 注册 Bean 是基于具体类的**，而一个接口可能有很多实现类，Spring 扫描到注解了 @Service 的接口不知道到底该实例化哪个实现类，因此会报错。
- **Spring 注入 Bean 是可以基于接口类的**，它会自动到容器中寻找一个实现了该接口的 Bean，但如果有多个实现类对象，那么就需要使用注解 @Qualifier 来根据 Bean 名称查找，否则还是会报错。

#### mapper

设置持久映射层接口，可以在方法中利用注解 @Select/@Update/@Insert/@Delete 实现简单的 SQL 映射关系，但是动态 SQL 和批量 SQL 就需要手动编写 XXXMapper.xml 映射文件。

需要注意的是，Mapper 是一个接口，并没有手写的实现类，Spring 会在启动时会扫描这些接口，并通过**JDK 动态代理**为其生成代理实现类，最终注入到 IoC 容器中，所以需要让 Spring 知道哪些接口是 MyBatis 接口，一种方式是添加 @Mapper 注解来逐个声明，一种方式是在启动类添加注解  @MapperScan("包名") 来批量声明。

#### SkyApplication

设置 SpringBoot 的启动类，需要在这里开启各种管理，本项目中用到的注解有

- **@SpringBootApplication**：标识这是入口类，其实集成了以下三个注解的功能
    - **@SpringBootConfiguration**：标识这是一个配置类，允许在类中写 @Bean 方法，把对象交给 IoC 容器
    - **@EnableAutoConfiguration**：开启 SpringBoot 的默认配置，会根据 classpath 下依赖的 Jar 包，自动加载对应的配置，不再需要手写 xml 文件或编写额外的配置类
    - **@ComponentScan**：开启组件扫描，默认扫描启动类所在包及其子包，因此启动类通常放在根路径下
- **@EnableTransactionManagement**：开启 SpringTX 功能，可以通过 **@Transactional** 实现事务控制
- **@EnableCaching**：开启 SpringCache 功能，可以通过 **@Cacheable** 和 **@CacheEvict** 实现自动缓存
- **@EnableScheduling**：开启 SpringTask 功能，可以通过 **@Scheduled** 设置定时任务



## 业务处理

> 指的是项目在传统 CRUD 上的扩展

### 哈希处理

前端获取到的密码是一个字符串并且直接传到了后端，显然不应该把明文字符串存到数据库里，不然一旦数据库被破解，所有用户的密码相当于直接暴露，而很多人的密码适用于不同网站，这样黑客就可以发起撞库攻击，所以密码一定要先做哈希再存入数据库。

需要注意的是，这里**并不是加密（Encryption），因为加密是可以通过密钥将密文解密回明文**，适用于 HTTPS 传输，这里**是哈希（Hashing），当且仅当输入同样的明文才会得到同样的哈希值，没有任何手段可以通过哈希值反向得到明文（只有一个一个去试）**。

所以为了防止数据泄漏，应该使用哈希而不是加密，否则黑客拿到密钥一样可以破解密码，而黑客拿到哈希值是毫无意义的。根据哈希的单向性质，验证密码的时候也只能先将传入进来的密码再哈希一次，再跟数据库取出来的哈希值进行比对。

在 `org.springframework.util` 包下，Spring 已经提供了很多常用的工具类，其中 `DigestUtils` 提供了 MD5 哈希算法，可以根据传入的字节数组生成 MD5 值并返回。

```java
password = DigestUtils.md5DigestAsHex(password.getBytes());
```

### 删除处理

该项目中非法删除的情况主要有两种，在类似的删除之前，需要先执行一次查询检查是否可以删除

- 正在启用中，即 status == 1，不能删除：正在售卖的 dish 不能被删除
- 被其他表引用，即存在外键约束，不能删除：被套餐引用的 dish 不能被删除

而数据库设计中，需要处理一些**级联删除**的情况，比如【dish, dish_flavor】【setmeal, dish, setmeal_dish】【order, order_detail, dish, setmeal】【shoppingcart, dish, setmeal】都存在外键关联的情况，因此**在删除 dish 的时候，不能只是 dish 表进行删除，还要对其他各种表拥有相同 dish_id 行进行删除**，写到这里我才发现，项目中实际上只对 setmeal_dish 和 dish_flavor 进行了处理，其他情况还是存在可能的错误。

```java
public void deleteBatch(List<Long> ids) {
    // 是否正在售卖
    for (Long id : ids) {
        Dish dish = dishMapper.getById(id);
        if (dish.getStatus().equals(StatusConstant.ENABLE)) {
            throw new DeletionNotAllowedException(MessageConstant.DISH_ON_SALE);
        }
    }

    // 是否被套餐关联
    List<Long> setmealId = setmealDishMapper.getSetmealIdsByDishIds(ids);
    if (setmealId != null && !setmealId.isEmpty()) {
        throw new DeletionNotAllowedException(MessageConstant.DISH_BE_RELATED_BY_SETMEAL);
    }

    // 删除菜品及其关联的口味
    dishFlavorMapper.deleteByDishIds(ids);
    dishMapper.deleteByIds(ids);
}
```

### 插入处理

上面提到了级联情况的删除处理，其实还是比较简单的，只要根据传入的 id 值，按照关联顺序，一个表一个表去找对应行删除就行了，但是级联情况的插入处理还是比较复杂的，可以总结为以下步骤：

1. 字段是否存在且有效，否则需要抛异常
2. 设置好实体对象的各个字段
3. 向表插入一条数据，同时获取到数据库提供的自增主键 id
4. 利用这个 id 设置好关联实体对象的各个字段
5. 遍历数据列表，向关联表插入多条数据

```java
public OrderSubmitVO submitOrder(OrdersSubmitDTO ordersSubmitDTO) {
    Long userId = IdContext.getCurrentId();

    // 查询地址簿，为空则抛异常
    AddressBook addressBook = addressBookMapper.getById(ordersSubmitDTO.getAddressBookId());
    if (addressBook == null) {
        throw new AddressBookBusinessException(MessageConstant.ADDRESS_BOOK_IS_NULL);
    }

    // 查询购物车，为空则抛异常
    ShoppingCart shoppingCart = new ShoppingCart();
    shoppingCart.setUserId(userId);
    List<ShoppingCart> shoppingCartList = shoppingCartMapper.list(shoppingCart);
    if (shoppingCartList == null || shoppingCartList.isEmpty()) {
        throw new ShoppingCartBusinessException(MessageConstant.SHOPPING_CART_IS_NULL);
    }

    // 向订单插入一条数据
    Orders orders = new Orders();
    BeanUtils.copyProperties(ordersSubmitDTO, orders);
    orders.setOrderTime(LocalDateTime.now());
    orders.setPayStatus(Orders.UN_PAID);
    orders.setStatus(Orders.PENDING_PAYMENT);
    orders.setNumber(String.valueOf(System.currentTimeMillis()));
    orders.setPhone(addressBook.getPhone());
    orders.setAddress(addressBook.getDetail());
    orders.setConsignee(addressBook.getConsignee());
    orders.setUserId(userId);
    orderMapper.insert(orders);

    // 向订单明细插入多条数据
    List<OrderDetail> orderDetailList = new ArrayList<>();
    for (ShoppingCart sc : shoppingCartList) {
        OrderDetail orderDetail = new OrderDetail();
        BeanUtils.copyProperties(sc, orderDetail);
        orderDetail.setOrderId(orders.getId());
        orderDetailList.add(orderDetail);
    }
    orderDetailMapper.insertBatch(orderDetailList);

  	// 以下是业务需求，不是固定需求，插入操作通常不绑定删除操作，且没有返回值
    shoppingCartMapper.cleanByUserId(userId);
    return OrderSubmitVO.builder()
            .id(orders.getId())
            .orderTime(orders.getOrderTime())
            .orderNumber(orders.getNumber())
            .orderAmount(orders.getAmount())
            .build();
}
```

### 更新/查询处理

项目中最有价值的一点就是，它只用了一个方法，就解决了所有条件更新和条件查询，具体流程为：

1. 构造一个新实体对象或 Map 对象
2. 按需利用 setter/builder/set 设置字段值
3. 用对象作为 Mapper 接口方法的参数
4. 在映射文件中用 `<where>` 和 `<set>` 搭配  `<if test=""></if>` 动态拼接 SQL 语句

这样做的最大好处：一是只用写单个方法就可以灵活处理各种各样地等值条件查询；二是可以直接利用 #{属性名/键值} 作为占位符，更符合面向对象的思路。如果只是传递若干个值，以后要扩展字段，要么是新写一个方法，要么是修改旧的方法签名，并且这样只能按照顺序填充，十分繁琐和不健壮。

当然，一种情况例外，那就是根据主键查询 getById，这是因为主键通常不会改动，而且扩展和修改也仅仅针对其他字段，所以作为单一的传参是完全可以接受的，而且 getById 这个方法会很频繁地用到，新建一个对象反而会消耗很大。

```java
<select id="list" resultType="com.sky.entity.Dish">
    select * from dish
    <where>
        <if test="name != null and name != ''">
            and name like concat('%',#{name},'%')
        </if>
        <if test="categoryId != null">
            and category_id = #{categoryId}
        </if>
        <if test="status != null">
            and status = #{status}
        </if>
    </where>
    order by create_time desc
</select>

<update id="update">
    update dish
    <set>
        <if test="name != null and name != ''">
            name = #{name},
        </if>
        <if test="categoryId != null">
            category_id = #{categoryId},
        </if>
        <if test="price != null">
            price = #{price},
        </if>
        <if test="image != null">
            image = #{image},
        </if>
        <if test="description != null">
            description = #{description},
        </if>
        <if test="status != null">
            status = #{status},
        </if>
        <if test="updateTime != null">
            update_time = #{updateTime},
        </if>
        <if test="updateUser != null">
            update_user = #{updateUser}
        </if>
    </set>
    where id = #{id}
</update>
```

### 日期处理

这里最有意义的一点就是要知道如何对日期进行处理，其中主要包括

- 利用 @DateTimeFormat 将前端传来的日期字符串转换为 LocalDate 日期对象
- 利用 plusDays() 和 minusDays() 获取相对当天的日期对象
- 利用 `LocalDateTime.of(LocalDate date, LocalTime.MIN/MAX)` 获取指定日期的最小时间和最大时间
- 在 mapper.xml 中使用日期作为筛选条件，从而获得指定时间范围内的数据，最后配合上聚合函数获得归约值

```java
@Override
public OrderReportVO getOrders(LocalDate startDate, LocalDate endDate) {
    // 获取日期列表
    List<LocalDate> dateList = getDateList(startDate, endDate);
    String dateListStr = StringUtils.join(dateList, ",");

    // 获取全部订单和完成订单
    List<Integer> totalOrderList = new ArrayList<>();
    List<Integer> completedOrderList = new ArrayList<>();
    Integer totalSum = 0;
    Integer completedSum = 0;
    for (LocalDate date : dateList) {
        LocalDateTime minTime = LocalDateTime.of(date, LocalTime.MIN);
        LocalDateTime maxTime = LocalDateTime.of(date, LocalTime.MAX);

        Map map = new HashMap();
        map.put("begin", minTime);
        map.put("end", maxTime);

        Integer totalNum = orderMapper.orderCount(map);
        totalOrderList.add(totalNum);
        totalSum += totalNum;

        map.put("status", Orders.COMPLETED);
        Integer completedNum = orderMapper.orderCount(map);
        completedOrderList.add(completedNum);
        completedSum += completedNum;
    }
    String totalOrderListStr = StringUtils.join(totalOrderList, ",");
    String completedOrderListStr = StringUtils.join(completedOrderList, ",");
    Double completedRate = (double) completedSum / totalSum;
    return OrderReportVO.builder()
            .dateList(dateListStr)
            .orderCountList(totalOrderListStr)
            .totalOrderCount(totalSum)
            .validOrderCountList(completedOrderListStr)
            .validOrderCount(completedSum)
            .orderCompletionRate(completedRate)
            .build();
}

/*
<select id="orderCount" resultType="java.lang.Integer">
    select count(id) from orders
    <where>
        <if test="begin != null">
            and order_time &gt; #{begin}
        </if>
        <if test="end != null">
            and order_time &lt; #{end}
        </if>
        <if test="status != null">
            and status = #{status}
        </if>
    </where>
</select>
*/
```



## 知识亮点

### Nginx

Nginx 是一个高性能的 **Web 服务器**

- **正向代理：客户端 -> 客户代理 -> 服务端**，客户端知道服务端，但是不想让服务端知道客户端（科学上网）
- **反向代理：客户端 -> 服务代理 -> 服务端**，服务端知道客户端，但是不想让客户端知道服务端（微服务）

所以 Nginx 的功能可以总结为以下几点：

- **接口映射**：配置 Nginx 接口到服务端接口的映射关系
- **负载均衡**：可以配置多个服务端并设置权重，Nginx 会把请求分发到多台后端服务器
- **防火墙**：可以限制 IP 和请求速率，起到网关作用，防止恶意 DDoS 和恶意爬虫
- **静态资源托管**：HTML、CSS、JS、图片、视频直接由 Nginx 提供，不必消耗后端服务器性能
- **HTTPS 终端**：SSL 证书可以配置在 Nginx，不必在每个后端都配置，使得 Nginx 可以与客户端建立 HTTPS 通信，而在内部与服务端建立 HTTP 通信，减少性能开销
- **跨域处理**：Nginx 可以统一设置响应头，解决前端跨域请求

```nginx
# 启动的 worker 进程数：通常设置为服务器 CPU 核心数，可以充分利用多核并发能力
worker_processes  1;

events {
    # 每个 worker 进程的最大连接数
    worker_connections  1024;
}

http {
    # 载入 MIME 类型配置，会自动设置响应头中的 Content-Type
    include       mime.types;
    # 默认 MIME 类型，如果无法识别类型，按照二进制流处理
    default_type  application/octet-stream;
    
  	# 开启高效文件传输
    sendfile        on;
    # 长连接超时时间，65s 内不会断开连接
    keepalive_timeout  65;
    
  	# 处理 WebSocket 升级请求
    map $http_upgrade $connection_upgrade {
        default upgrade;
        '' close;
    }

    # 定义上游服务器集群，也就是反向代理的目标，其中 weight 越大请求走的可能性越大
    upstream webservers {
      server 127.0.0.1:8080 weight=60;
    	# server 127.0.0.1:8081 weight=20;
    	# server 127.0.0.2:8080 weight=20;
    }
  
		# 反向代理的配置
    server {
        # Nginx 监听的服务器名称和端口
        listen       8088;
        server_name  localhost;
    
        # 自定义错误页，即当服务器返回 500、502、503、504 错误时，统一展示 /50x.html 页面
        error_page   500 502 503 504  /50x.html;

        # 静态资源的映射
        location / {
            root   /Users/wyw/Desktop/BackEnd/HeiMaTakeOut/sky-take-out-frontend/sky;
            index  index.html;
        }
			
    		# 错误页面的映射，实际访问 ${nginx 安装目录}/html/50x.html
        location = /50x.html {
            root   html;
        }

        # API 的反向代理，其中 webservers 就是上面定义的上游服务器集群
        location /api/ {
            proxy_pass   http://webservers/admin/;
        }
        location /user/ {
            proxy_pass   http://webservers/user/;
        }
        location /ws/ {
            proxy_pass   http://webservers/ws/;
            proxy_http_version 1.1;
            proxy_read_timeout 3600s;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "$connection_upgrade";
        }
    }
}
```

### RESTful

在还没有学到 Java 的时候，我都是用 Python 的 Flask 框架来实现后端，那个时候每个操作我都定义了一个全新的路径，而且后端是直接拿到 json 根据键值来获取属性值，没有用到面向对象的思想。

现在我意识到，在 RESTful 风格下，除了根据 URL 路径区分请求，还可以根据 HTTP 方法区分请求，路径代表资源，方法代表动作，也就是**利用 @RequestMapping 和 @XxxMapping 的 value 属性定义资源，利用 @XxxMapping 定义方法**。

```text
GET     /orders        → 查询订单列表
POST    /orders        → 创建订单
GET     /orders/1001   → 查询订单 1001
PUT     /orders/1001   → 更新订单 1001
DELETE  /orders/1001   → 删除订单 1001
```

除此之外，RESTful 通常要求前后端使用 JSON 格式的数据进行交互，而 Java 对象和 JavaScript 对象天然就与 JSON 格式高度契合，因此**只要约定好传输字段，定义好 DTO 和 VO，就可以直接利用 @RequestBody 和 @ReponseBody 实现 JSON 数据和 Java 对象之间的自动映射**，再也不需要获取并解析原始的 JSON 对象，而是直接面向对象来操作。

```java
@RestController(value = "adminCategoryController")
@RequestMapping(value = "/admin/category")
public class CategoryController {
    @Autowired
    private CategoryService categoryService;

    @PostMapping
    public Result<String> saveCategory(@RequestBody CategoryDTO categoryDTO){
        categoryService.saveCategory(categoryDTO);
        return Result.success();
    }
  
    @DeleteMapping
    public Result<String> deleteCategory(Long id){
        categoryService.deleteById(id);
        return Result.success();
    }

    @PutMapping
    public Result<String> updateCategory(@RequestBody CategoryDTO categoryDTO){
        categoryService.updateCategory(categoryDTO);
        return Result.success();
    }

    @GetMapping("/page")
    public Result<PageResult> pageQuery(CategoryPageQueryDTO categoryPageQueryDTO){
        PageResult pageResult = categoryService.pageQuery(categoryPageQueryDTO);
        return Result.success(pageResult);
    }
  
    @GetMapping("/list")
    public Result<List<Category>> listCategory(Integer type){
        List<Category> list = categoryService.listByType(type);
        return Result.success(list);
    }

    @PostMapping("/status/{status}")
    public Result<String> startOrStop(@PathVariable("status") Integer status, @RequestParam Long id){
        categoryService.startOrStop(status,id);
        return Result.success();
    }
}
```

### PageHelper

PageHelper 是 MyBatis 提供的分页插件，可以数据库查询时自动生成带分页的 SQL，而不需要手动写 LIMIT offset, pageSize，其中 **offset = (pageNum - 1) * pageSize**，此外它还会自动生成 COUNT(*) 查询来统计总条数。

但是需要注意的是，在使用 PageHelper 进行分页时，返回结果通常会用到 **Page\<T> 类型**，泛型传递实际需要的数据类型即可，**它本质上就是继承自 ArrayList\<T>，只不过在内部封装了分页结果的集合和分页相关的元数据**。使用流程为：

1. **PageHelper.startPage(pageNum, pageSize)**：底层会把分页参数放到当前线程的 ThreadLocal 中，然后 MyBatis 在执行线程的**第一个查询语句**时，会从 ThreadLocal 中获取到分页参数，自动对 SQL 进行改写
2. 正常编写 Mapper 查询方法，参数也一样，只不过返回值使用 Page\<T>，而不是 List\<T>
3. 调用 getter 获取属性值，其中最主要的就是 getTotal() 获取总记录数和 getResult() 获取当前页记录

```java
public PageResult pageQuery(DishPageQueryDTO dishPageQueryDTO) {
    PageHelper.startPage(dishPageQueryDTO.getPage(), dishPageQueryDTO.getPageSize());
    Page<DishVO> page = dishMapper.pageQuery(dishPageQueryDTO);
    return new PageResult(page.getTotal(), page.getResult());
}
```

### SLF4J

SLF4J 是一个日志门面框架，它本身并不是用来输出日志的，而是定义了统一的日志 API，实际的日志记录工作由底层绑定的日志框架（如 Logback、Log4j、Log4j2）来完成。

说白了就是因为不同日志框架的 API 设计各不相同，如果直接使用某个框架写日志代码，未来要切换实现就必须修改所有日志调用，需要对每个文件都改动，而 SLF4J 就统一了 API，让每个日志框架都提供与 SLF4J 的绑定器，这样只需要在 maven 中切换不同依赖，虽然看起来始终调用 SLF4J 提供的 API，但底层是由绑定的日志框架来完成真正的输出。使用 SLF4J 很简单：

1. 在 maven 引入 slf4j-api 和对应的日志框架
2. **利用 Lombok 提供的 @Slf4j 注解，会自动为类生成一个 Logger log 对象**，这样就不需要手动为每个类引入
3. 在方法中直接使用 log 的方法 log.debug() / log.info() / log.warn() / log.error() 来输出日志

### JWT

#### 原理分析

JWT 是一种基于 JSON 格式的轻量级令牌，可以理解为一个凭证，常用于表明客户端表明身份，它实际上是一个字符串，由三部分组成并用 `.` 分隔

- header：声明哈希算法
- payload：承载用户数据和过期时间
- signature：签名，利用 header 中声明的哈希算法，将 header 和 payload 组成的字符串经过 Base64Url 编码后再进行哈希得到的字符串

```text
signature = Hash( base64url(header) + "." + base64url(payload), secretKey )
```

为什么需要签名我理解了很久，其实还是要从安全角度入手，**因为 header 和 payload 只是经过了 Base64Url 编码，既不属于加密也不属于哈希，任何人都可以解码查看原始内容**，这样服务端就无法得知客户端传来的数据到底是伪造的还是真实的，因此服务端就需要一个只有自己可以知道的值，这就是签名。

那么接下来的关键就在于这个密钥，这个密钥是服务端才有的，服务端只需要先用设定好的 header + secretKey 和需要传输的 payload 算一次签名，然后将三者组合成令牌响应给客户端，客户端在之后每一次请求都带上这个令牌，**服务端只需要获取令牌中的 header + payload，搭配上私有的密钥再算一次签名，最后跟 token 里的签名对比，如果一致则说明身份是合法的，否则说明要么 header 或 payload 被篡改了，要么签名是伪造的**。

所以，这里利用到的核心思想就是，只有知道 secretKey，才可以根据 header 和 payload 算出正确且唯一的 signature，而 secretKey 当且仅有服务端知道，所以签名只能由服务端生成和验证。

#### 代码分析

```java
public class JwtUtil {
    public static String createJWT(String secretKey, long ttlMillis, Map<String, Object> claims) {
        // 指定签名算法
        SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.HS256;

        // 指定过期时间（时间戳）
        long expMillis = System.currentTimeMillis() + ttlMillis;
        Date exp = new Date(expMillis);

        // 创建构造器，设置 header、payload、secretKey
        JwtBuilder builder = Jwts.builder()
                .setClaims(claims)
                .signWith(signatureAlgorithm, secretKey.getBytes(StandardCharsets.UTF_8))
                .setExpiration(exp); // exp 会自动封装到 payload

      	// 计算签名，并生成最终的 JWT 令牌
        return builder.compact();
    }

    public static Claims parseJWT(String secretKey, String token) {
      	// 创建解析器，设置 secretKey
        JwtParser parser = Jwts.parser().setSigningKey(secretKey);
      
      	// 根据 token 中的 header 和 payload 计算签名，然后与 signature 进行比对
        Jws<Claims> claimsJws = parser.parseClaimsJws(token);
      
      	// 比对失败会直接抛出异常，比对成功就可以取出 payload
        return claimsJws.getBody();
    }
}
```

#### 使用分析

生成令牌并返回很简单，只需要调用 JwtUtil 的静态方法 createJWT，然后放到 VO 返回就好了，但是校验令牌却需要注意，我们显然不希望在每个 Controller 方法都执行一次校验逻辑，而且我们获取到的 payload 并不是在 Controller 用到，可能在 Service 或其他地方用到，这个时候用拦截器和 ThreadLocal 就非常适合，因为**拦截器是针对所有请求的，而 ThreadLocal 是针对整个请求域的**。

```java
@Component
@Slf4j
public class JwtTokenAdminInterceptor implements HandlerInterceptor {

    @Autowired
    private JwtProperties jwtProperties;
		
  	@Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        // 如果请求走的是 Controller 方法，那么 handler 就是 HandlerMethod 类型，需要校验
        // 如果请求的是静态资源，头部是没有 JWT 令牌的，不需要进行校验，直接放行
        if (!(handler instanceof HandlerMethod)) {
            return true;
        }

        // 1. 从请求头中获取令牌
        String token = request.getHeader(jwtProperties.getAdminTokenName());

        // 2. 调用工具类，校验并解析令牌，得到 ID 存到 ThreadLocal 中
        try {
            log.info("请求路径：{}", request.getRequestURI());
            Claims claims = JwtUtil.parseJWT(jwtProperties.getAdminSecretKey(), token);
            Long empId = Long.valueOf(claims.get(JwtClaimsConstant.EMP_ID).toString());
            log.info("根据令牌解析得到当前员工 id：{}", empId);
            IdContext.setCurrentId(empId);
            return true;
        }
        // 3. 捕获异常，代表校验令牌失败，响应 401 状态码
        catch (Exception ex) {
            log.error("JWT 令牌解析失败");
            response.setStatus(401);
            return false;
        }
    }
}
```

定义好的拦截器需要在 SpringMVC 的配置类中进行注册

- addInterceptors：向注册器中添加自定义的拦截器
- addPathPatterns：设置拦截器处理的请求 URL
- excludePathPatterns：设置拦截器不处理的请求 URL（登录的时候肯定还不存在令牌，令牌就是在登陆成功后才返回的）

```java
@Autowired
private JwtTokenAdminInterceptor jwtTokenAdminInterceptor;
@Autowired
private JwtTokenUserInterceptor jwtTokenUserInterceptor;

@Override
protected void addInterceptors(InterceptorRegistry registry) {
    log.info("正在配置：JWT 令牌拦截器");
    registry.addInterceptor(jwtTokenAdminInterceptor)
            .addPathPatterns("/admin/**")
            .excludePathPatterns("/admin/employee/login");
    registry.addInterceptor(jwtTokenUserInterceptor)
            .addPathPatterns("/user/**")
            .excludePathPatterns("/user/user/login")
            .excludePathPatterns("/user/shop/status");
}
```

### Swagger

Swagger 其实就是一个 **API 文档生成和测试工具**，它可以自动扫描项目中的 Controller 和接口注解，并且自动为我们生成可视化的在线接口网页，支持在网页上直接调试 API，就不需要通过 Postman 等工具调试

| 注解              | 参数                                                         | 功能                             |
| ----------------- | ------------------------------------------------------------ | -------------------------------- |
| @Api              | tags：分组名称<br />description：分组描述<br />protocols：支持协议 | 注解在类上，描述接口的分组       |
| @ApiOperation     | value：接口名称<br />notes：接口描述<br />httpMethod：请求方法<br />response：返回类型 | 注解在方法上，描述接口的功能     |
| @ApiParam         | value：参数描述<br />required：是否必须<br />example：示例值 | 注解在方法参数上，描述参数的意义 |
| @ApiModel         | value：实体名称<br />description：实体描述                   | 注解在类上，描述实体信息         |
| @ApiModelProperty | value：属性名称<br />example：示例值                         | 注解在属性上，描述属性信息       |

![image-20250821215520441](https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/Java/SpringMVC202508212155068.png)

不过使用 Swagger 有两件事需要注意

- 需要一个配置类，手动设置 Swagger 扫描的包来找到相关注解，然后注册 Docket 对象作为容器的 Bean，这样才能自动生成动态网页
- 由于动态网页是静态资源，不应该走 DispatcherServlet，所以要主动设置静态文件映射

```java
@Configuration
@Slf4j
public class SwaggerConfiguration {

    @Bean
    public Docket adminDocket() {
        log.info("正在配置：管理端接口文档");
        ApiInfo apiInfo = new ApiInfoBuilder()
                .title("苍穹外卖项目接口文档")
                .version("2.0")
                .description("管理端接口文档")
                .build();

        return new Docket(DocumentationType.SWAGGER_2)
                .groupName("管理端接口")
                .apiInfo(apiInfo)
                .select()
                .apis(RequestHandlerSelectors.basePackage("com.sky.controller.admin"))
                .paths(PathSelectors.any())
                .build();
    }

    @Bean
    public Docket userDocket() {
        log.info("正在配置：用户端接口文档");
        ApiInfo apiInfo = new ApiInfoBuilder()
                .title("苍穹外卖项目接口文档")
                .version("2.0")
                .description("用户端接口文档")
                .build();

        return new Docket(DocumentationType.SWAGGER_2)
                .groupName("用户端接口")
                .apiInfo(apiInfo)
                .select()
                .apis(RequestHandlerSelectors.basePackage("com.sky.controller.user"))
                .paths(PathSelectors.any())
                .build();
    }
}
```

### OSS

OSS（Object Storage Service）对象存储服务，其实就是一种云端技术，把文件（图片、视频、文档）当作对象存储到云端，而不是存储到硬盘，这样获取数据的方式就不再是读取磁盘，而是通过 HTTP/HTTPS 协议从网络获取，这样做有几个很明显的好处

- **按需付费**：用多少算多少，不必一次性投入大量硬件成本，防止存储过剩
- **弹性扩展**：不像传统磁盘或文件服务器有容量上限，OSS 可以按需扩容，理论上无限大
- **高可用**：可以购买相关产品，由云厂商提供多地容灾和自动备份，降低数据丢失和服务中断风险
- **权限控制**：支持 Bucket 级别和对象级别的访问权限
- **高效运维**：云厂商提供监控、日志、告警、自动修复工具
- **便捷访问**：OSS 通过 RESTful API + CDN 加速，可以应对高并发的使用场景

OSS 使用 HTTP/HTTPS 协议提供文件访问服务，那么对应的 URL 就应该是唯一的，这时候就就必须有一个命名空间来隔离不同用户的资源，而存储空间在 OSS 中称作为 bucket，拼接 URL 的规则为：`https://<BucketName>.<Endpoint>/<ObjectName>`

- BucketName：存储空间名，要求在同一个区域唯一，比如 sky-take-out-bucket
- Endpoint：地域节点，指定存储在哪个 OSS 数据中心，比如 oss-cn-shanghai.aliyuncs.com
- ObjectName：对象名，即完整的文件路径，比如 static/img/avatar.png

```java
public String upload(byte[] bytes, String objectName) {
    // 1. 创建 OSSClient 实例：传递账号凭证，成为 OSS 服务的客户端
    OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);

    // 2. 调用 putObject 方法：传递 bucketName、objectName 以及文件字节流
    try {
        ossClient.putObject(bucketName, objectName, new ByteArrayInputStream(bytes));
    } 
  	// 3. 当 OSS 返回错误响应时抛出异常（权限不足、bucket 不存在）
  	catch (OSSException oe) {
        System.out.println("Caught an OSSException：reach but rejected.");
        System.out.println("Error Message:" + oe.getErrorMessage());
    } 
  	// 4. 当没有收到任何响应时抛出异常（地址错误、网络异常）
  	catch (ClientException ce) {
        System.out.println("Caught an ClientException: not reach");
        System.out.println("Error Message:" + ce.getMessage());
    } 
  	// 5. 关闭连接，因为 ossClient 内部维护了 HTTP 连接池，会占用资源
  	finally {
        if (ossClient != null) {
            ossClient.shutdown();
        }
    }
  
    // 6. 拼接 URL：https://<bucketName>.<endpoint>/<objectName>
    StringBuilder stringBuilder = new StringBuilder();
    stringBuilder
      			.append("https://")
            .append(bucketName)
            .append(".")
            .append(endpoint)
            .append("/")
            .append(objectName);

    // 7. 拼接 URL，规则是：https://<bucketName>.<endpoint>/<objectName>
    String url = "https://" + bucketName + "." + endpoint + "/" + objectName;

    // 8. 返回 URL，存储到数据库之中
    log.info("文件上传到：{}", url);
  	return url;
}
```

![image-20250821223750291](https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/Java/SpringMVC202508212237471.png)

### @AutoFill

之前已经说过自定义注解的一个重要功能就是作为切面的切入点，在项目中的意义就在于，很多表具有创建人、创建时间、更新人和更新时间的字段，这些东西的插入/更新逻辑是完全一样的，但是又没有办法封装为一个类方法，因为他是在多个业务类使用的，而如果把它封装为一个工具类方法，又需要在每个地方都多加一行，太繁琐。因此，封装为一个切面动态织入，在插入/更新数据库时，自动为这些公共字段赋值，就非常优雅。

```java
// 利用枚举进行类型检查：UPDATE / INSERT
public enum OperationType {
    UPDATE,
    INSERT
}

// 约束注解只能作用于方法上
@Target(ElementType.METHOD)
// 约束注解在运行时也可以使用
@Retention(RetentionPolicy.RUNTIME)
public @interface AutoFill {
    // 定义注解属性，value 指定数据库操作类型
    OperationType value();
}
```

而对这些字段进行操作显然是在持久层进行的，也就是只需要在 Mapper 接口上添加这些注解即可。但是，添加注解的目的只是为了标识，真正的逻辑需要写切入点表达式和切面来处理，其中切入点表达式有两个条件，一个是 mapper 包下的类，一个是带有自定义注解 @AutoFill，而切面逻辑就是调用反射，获取到传入的对象类型，通过反射调用 setter 将值注入即可。

```java
@Aspect
@Component
public class AutoFillAspect {
  	// 切入点表达式：mapper 包 && AutoFill 注解
    @Pointcut(" execution(* com.sky.mapper.*.*(..)) && @annotation(com.sky.annotation.AutoFill)")
    public void autoFillPointCut(){}

		// 前置通知：因为是先注入再存储
    @Before("autoFillPointCut()")
    public void autoFill(JoinPoint joinPoint){
      	// 获取方法签名：返回值+名字+传参
        MethodSignature signature = (MethodSignature) joinPoint.getSignature();

        // 获取注解属性：UPDATE/INSERT
        AutoFill autoFill = signature.getMethod().getAnnotation(AutoFill.class);
        OperationType operationType = autoFill.value();

        // 获取传参类型：实体对象
        Object entity = joinPoint.getArgs()[0];
      	Class<?> clazz = entity.getClass();

        // 获取填充数据：id+time
        LocalDateTime now = LocalDateTime.now();
        Long currentId = IdContext.getCurrentId();

        // 通过类型反射获取并调用 setter 方法
        try {
            Method setCreateTime = clazz.getDeclaredMethod(AutoFillConstant.SET_CREATE_TIME, LocalDateTime.class);
            Method setCreateUser = clazz.getDeclaredMethod(AutoFillConstant.SET_CREATE_USER, Long.class);
            Method setUpdateTime = clazz.getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME, LocalDateTime.class);
            Method setUpdateUser = clazz.getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER, Long.class);
          	setUpdateTime.invoke(entity, now);
            setUpdateUser.invoke(entity, currentId);
          	if (operationType == OperationType.INSERT) {
                setCreateTime.invoke(entity, now);
                setCreateUser.invoke(entity, currentId);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

### @ExceptionHandler

在之前就已经说了 BaseException 的定义和意义，但是就跟自定义注解一样，他只是起到了一个标识作用，真正让他发挥作用的是自定义的异常处理器，在这里面设置他处理什么异常以及如何处理异常。

1. 捕获 BaseException，因为我们定义的业务异常都是继承 BaseException 的，也就是说只要声明捕获 BaseException 对象，就会捕获其所有子类，不需要再一个个捕获，而且很好地与其他 RuntimeException 的处理逻辑隔离开来。
2. 捕获 SQLIntegrityConstraintViolationException 异常，这是因为在判断用户名是否唯一的时候，传统方法是先查，如果存在就抛出异常，如果不存在就存，也就是可能需要两次数据库操作。实际上，我们可以无论如何都执行插入操作，而数据库本身对 username 就设置了唯一性约束，如果重复会自动抛出完整性异常，我们可以捕获这个异常来处理，就不需要单独设置业务异常，这样无论如何只需要一次数据库操作。

```java
@RestControllerAdvice
public class GlobalExceptionHandler {
    // 捕获基础异常进行处理，BaseException 是自定义的异常类型，继承自 RuntimeException
    @ExceptionHandler
    public Result<Void> exceptionHandler(BaseException ex){
        return Result.error(ex.getMessage());
    }

    // 捕获 SQL 的完整性约束异常进行处理
    @ExceptionHandler
    public Result<Void> exceptionHandler(SQLIntegrityConstraintViolationException ex){
        // 获取异常信息
        String message = ex.getMessage();

        // 处理唯一性约束：Duplicate entry 'xxx' for key 'employee.idx_username'
        if (message.contains("Duplicate entry")){
            // 1. 得到空格划分的子字符串
            String[] splitMessage = message.split(" ");
            // 2. 获取第 3 个字符串
            String username = splitMessage[2];
            // 3. 构造错误提示信息
            String msg = username + MessageConstant.ALREADY_EXISTS;
            // 4. 封装为 Result 对象
            return Result.error(msg);
        }
        // 可以继续添加其他类型的完整性约束异常
        //else if (message.contains("xxxx")){
        //}
        // 如果没有就返回未知错误
        else {
            return Result.error(MessageConstant.UNKNOWN_ERROR);
        }
    }
}
```

### HttpClient

我们都知道，客户端-服务端只是一种模式，后端不代表服务端，后端也可以作为客户端调用别的平台的 api 来获取数据。而 HttpClient 就是 JDK 提供给我们的一种将当前程序作为 HTTP 协议中的客户端来访问 URL 获取资源的一种简便方式。

```java
public static String doGet(String url,Map<String,String> paramMap){
    // 1. 创建 Httpclient 对象
    CloseableHttpClient httpClient = HttpClients.createDefault();
		
  	// 2. 创建响应接收对象 response
    CloseableHttpResponse response = null;
    String result = "";

    try{
      	// 3. 添加请求参数
        URIBuilder builder = new URIBuilder(url);
        if(paramMap != null){
            for (String key : paramMap.keySet()) {
                builder.addParameter(key,paramMap.get(key));
            }
        }
      
      	// 4. 构造 URI 对象
        URI uri = builder.build();

        // 5. 创建 GET 请求对象
        HttpGet httpGet = new HttpGet(uri);

        // 6. 利用客户端对象执行请求对象返回到响应对象
        response = httpClient.execute(httpGet);

      	// 7. 把响应体里的 JSON 请求体转成 String 返回
        if(response.getStatusLine().getStatusCode() == 200){
            result = EntityUtils.toString(response.getEntity(),"UTF-8");
        }
    }catch (Exception e){
        e.printStackTrace();
    }finally {
        try {
            response.close();
            httpClient.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    return result;
}
```

在项目中，主要用到的地方是小程序的微信登录，其流程为如下，所以可以很清晰的知道，就是在第二步和第三步，封装好请求参数，使用 HttpClient 获取到 openid 即可。

1. 前端通过 wx.login() 拿到一个临时且一次性的 code，发送到后端服务器
2. 后端使用 appid + appSecret + code 调用微信官方接口 jscode2session
3. 微信返回 openid（用户的唯一标识） 和 session_key（后端与微信的会话密钥） 
4. 后端根据 opened 生成自定义 JWT token 返回给前端，同时把 openid 和 session_key 关联存储到 Redis
5. 前端获取到 token 后存储到 storage 中，然后在之后的请求中带上 token
6. 后端收到请求检验 token 是否有效且合法，通过后响应

```java
// 微信登录服务的接口地址（固定的）
public static final String WX_LOGIN_API = "https://api.weixin.qq.com/sns/jscode2session";

// 注入微信小程序的配置信息
@Autowired
private WeChatProperties weChatProperties;

// 获取 openid：转换为 Json 对象，获取到需要的字段即可
private String getOpenId(String code) {
    Map<String, String> params = new HashMap<>();
    params.put("appid", weChatProperties.getAppid());
    params.put("secret", weChatProperties.getSecret());
    params.put("js_code", code);
    params.put("grant_type", "authorization_code");
    String json = HttpClientUtil.doGet(WX_LOGIN_API, params);
    JSONObject jsonObject = JSONObject.parseObject(json);
    return jsonObject.getString("openid");
}
```

### SpringCache

以往使用 Redis 的做法，是需要注入 RedisTemplate，先获取它的方法对象比如 `opsForValue()`，然后再调用提供的 Redis 操作 API 比如 `get()/put()/delete()` 这些。如果大量地方需要使用缓存，我们将不得不在业务层写一大堆完全一样的代码，只不过把键进行了更换，而且如果更新/删除时忘记清理缓存，甚至会造成数据不一致的严重问题。

而 SpringCache 是 Spring 提供的统一缓存 API，底层可以自由切换 Redis、Ehcache 等实现，只需要声明注解，缓存逻辑就可以自动由 Spring 完成，一般放在 Controller 上，直接缓存返回的结果。

常见的注解有：

- **@EnableCaching**：在 Spring 启动类上，开启 Spring 提供的注解缓存功能
- **@Cacheable**：在方法执行前先检查缓存，如果存在就返回缓存结果，否则自动把返回结果放入缓存
- **@CachePut**：在方法执行后，将返回结果用于更新缓存
- **@CacheEvict**：在方法执行后，清空整个缓存

常见的属性有：

- **cacheNames**：指定缓存的名字
- **key**：指定缓存的键值
- **allEntries**：是否清空整个缓存分区，默认为 false，只适用于，@CacheEvict
- **beforeInvocation**：是否在执行之前清除缓存，默认为 false，@CacheEvict
- **condition**：满足条件才执行缓存逻辑
- **unless**：满足条件时不缓存

```java
// B 端：删除缓存
@CacheEvict(cacheNames = "dishCache", allEntries = true)
@DeleteMapping
public Result<Void> delete(@RequestParam List<Long> ids) {
    dishService.deleteBatch(ids);
    return Result.success();
}

// C 端：查询缓存
@Cacheable(cacheNames = "dishCache", key = "#categoryId")
@GetMapping("/list")
public Result<List<DishVO>> list(@RequestParam Long categoryId) {
    Dish dish = new Dish();
    dish.setCategoryId(categoryId);
    dish.setStatus(StatusConstant.ENABLE);
    List<DishVO> list = dishService.listFlavorByDish(dish);
    return Result.success(list);
}
```

### SpringTask

传统的定时任务思路一般是自己开一个 Thread 或者用 ScheduledExecutorService，然后在里面写死一个 while(true) 循环，每次 sleep() 一段时间再执行逻辑，这样做一是浪费资源，二是很难编写复杂的时间间隔，三是不能很好地利用 IoC 容器。

而 SpringTask 就是对这种传统线程轮询的封装，他把定时任务注册为 Bean，交给容器自动处理，并且**只要在启动类注解 @EnableScheduling，就可以用 @Scheduled 注解搭配 cron  属性来配置定时任务和自定义触发时间**。

- 特殊字符

    - *：任意值。例如，秒域 * 表示“每秒执行”

    - ,：枚举值。例如，分域 0,15,30,45 表示“在 0、15、30、45 分钟执行”

    - -：范围。例如，时域 10-12 表示“10 点、11 点、12 点执行”

    - /：步长。例如，秒域 0/5 表示“从 0 秒开始，每隔 5 秒执行一次”

- 日与周

    - ?：表示“不指定值”。日和星期不能同时指定，就用 ? 占位

    - L：last，最后。例如，日域 L 表示“本月最后一天”；星期域 L 表示“星期六”

    - W：工作日。例如，日域 15W 表示“离 15 号最近的工作日”

    - \#：第几个星期几。例如，星期域 2#1 表示“本月第一个星期一”

- 常见例子

    - `*/5 * * * * *`：每五秒
    - `0 */1 * * * *`：每分钟
    - `0 0 0,12 * * ?`：每天 0 点和 12 点
    - `0 0 18 ? * MON-FRI`：工作物下午 6 点
    - `0 59 23 31 12 ?`：每年 12 月 31 日 23:59 执行

```java
@Component
public class OrderTask {
    @Autowired
    private OrderMapper orderMapper;
		
  	// 每 2 分钟
    @Scheduled(cron = "0 0/2 * * * ?")
    public void payTask() {
        // 查找所有待支付且超时的订单
        LocalDateTime ddl = LocalDateTime.now().plusMinutes(-15);
        List<Orders> ordersList = orderMapper.getByStatusAndOrderTime(Orders.PENDING_PAYMENT, ddl);

        // 设置取消并更改数据库
        if (ordersList != null && !ordersList.isEmpty()) {
            ordersList.forEach(orders -> {
                orders.setStatus(Orders.CANCELLED);
                orders.setCancelReason("订单超过 15 分钟未支付");
                orders.setCancelTime(LocalDateTime.now());
                orderMapper.update(orders);
            });
        }
    }

  	// 每天 00:30 执行
    @Scheduled(cron = "0 30 0 * * ?")
    public void deliveryTask() {
        // 查找所有待支付且超时的订单
        LocalDateTime ddl = LocalDateTime.now().plusMinutes(-30);
        List<Orders> ordersList = orderMapper.getByStatusAndOrderTime(Orders.DELIVERY_IN_PROGRESS, ddl);

        // 设置完成并更改数据库
        if (ordersList != null && !ordersList.isEmpty()) {
            ordersList.forEach(orders -> {
                orders.setStatus(Orders.COMPLETED);
                orderMapper.update(orders);
            });
        }
    }
}
```

### WebSocket

WebSocket 并不是一个简单的工具，它其实是一种网络通信协议，由 HTML5 提出，专门用于在**浏览器和服务器之间建立长连接、实现双向通信**，常用于即时通讯、实时通知和传感数据。一句话，就是前后端在这里不再是客户端和服务端的关系，而就是通信的双方。而在 Spring 中，完全可以把后端的 WebSocket 注册为一个 Bean，全权交给容器来处理，每当有一个新的客户端与服务端成功建立 WebSocket 连接时，框架就会自动创建一个**唯一的 Session 对象**进行注入，并且会自动调用对应的回调方法，此外也可以自定义方法，调用 Session 对象的 api 实现接发消息。流程为：

1. 在类上注解 **@ServerEndpoint("/ws/{sid}")**，当客户端连接到 /ws/{sid} 这个地址时，就由这个类处理通信逻辑
2. 注解方法 **@OnOpen、@OnMessage、@OnClose**，对 session 对象的生命周期设置回调逻辑
3. 调用 API `.getBasicRemote().sendText()` 发送消息

```java
@Component
@ServerEndpoint("/ws/{sid}")
@Slf4j
public class WebSocketServer {

    private static Map<String, Session> sessions = new HashMap<>();

    @OnOpen
    public void onOpen(Session session, @PathParam("sid") String sid) {
        log.info("服务端与客户端 {} 建立连接", sid);
        sessions.put(sid, session);
    }

    @OnMessage
    public void onMessage(String message, @PathParam("sid") String sid) {
        log.info("服务端受到客户端 {} 的消息：{}", sid, message);
    }

    @OnClose
    public void onClose(@PathParam("sid") String sid) {
        log.info("服务端断开与客户端 {} 的连接", sid);
        sessions.remove(sid);
    }

    // 广播数据
    public void broadcast(String message) {
        log.info("服务端广播了一条消息: {}", message);
        for (Session session : sessions.values()) {
            try {
                session.getBasicRemote().sendText(message);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
}
```

### ECharts/POI

ECharts 是由 Apache 基金会**使用 JavaScript 编写的开源数据可视化库**，只需要调用 API 提供数据并设置显示样式，就可以在页面中实现数据可视化，由于是前端知识，在这里就不赘述了。

POI 也是由 Apache 基金会**使用 Java 编写的进行读写 Microsoft Office 文件的工具库**，常见方法有

- `XSSFWorkbook workbook = new XSSFWorkbook(inputStream)`：从输入流读取文件对象
- `XSSFSheet sheet = workbook.getSheet(...)`：获取工作表对象
- `XSSFRow row = sheet.getRow(...)`：获取表格行对象
- `XSSFCell cell = row.getCell(...)`：获取单元格对象
- `cell.setCellValue(...)`：设置单元格内容
- `workbook.write(outputStream)`：将文件对象写到输出流