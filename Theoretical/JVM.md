# JVM



## 概念

### JDK（Java Development Kit）

是用于开发 Java 程序的完整套件，包含 JRE 和开发工具

- javac：将字符源码编译为字节码，也就是将 .java 文件编译为 .class 文件
- javadoc：从源码的 `/**...*/` 注释自动生成 API 文档
- jar：将 Java 程序打包为一个 .jar 文件，以及从 .jar 文件解包为 Java 程序
- jdb：命令行调试器，连接 JVM，支持断点、单步、打印变量、线程控制等操作

### JRE（Java Runtime Environment）

是用于运行 Java 程序的运行环境，包含 JVM 和标准类库

- java.base：包含 lang、util、io、nio 等，是 Java 程序的核心依赖类
- java.sql：提供数据库连接和 SQL 操作的标准接口

### JVM（Java Virtual Machine） 

是用于运行 Java 字节码（.class 文件）的虚拟机，通过封装底层硬件平台的差异，使得 Java 程序可以在不同平台运行

- 解释器（interpreter）：运行时逐条读取字节码并按语义直接在宿主上执行，不会为字节码生成本地机器码
- JIT（Just-In-Time）：在运行时把热点字节码编译为机器码并缓存

### 关系

<img src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/Java/202509162330784.png" alt="image-20250916233051698" style="zoom: 50%;" />

### HotSpot

JVM 本质上只是一种思想和规范，具有很多实现如 HotSpot、JRockit、Zulu、ART 等，其中 HotSpot 是目前最广泛使用的实现，同时也是 OpenJDK 的默认实现



##内存

### 进程内存布局

JVM 内存：由 JVM 管理的内存，是预先设置好初始值和最大值的内存，主要有堆和栈

本地内存：由进程管理的内存，是从操作系统动态分配的内存，主要有元空间和直接内存

<img src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/Java/202509162331896.png" alt="image-20250916233140809" style="zoom: 50%;" />



### 栈 Stack

#### 内存布局

这里的栈指的是一个线程所占据的内存空间，线程是 JVM 中执行代码的最小单位，每个线程都有自己的执行上下文和内存空间，同时也与其他线程共享堆和本地内存

<img src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/Java/202509162332105.png" alt="image-20250916233237006" style="zoom:50%;" />

#### 虚拟机栈 / 本地方法栈

**虚拟机栈**：简称栈，是每个 Java 线程私有的内存区域，生命周期和线程一致，负责存放方法执行的栈帧，用于方法调用、局部变量保存、操作数计算和控制流管理

**栈帧**：每次方法调用时都会创建一个栈帧压入该线程的栈，方法返回时弹出并销毁该栈帧，每个栈帧包含局部变量表、操作数栈、动态链接、方法返回地址

- **局部变量表**：存放了编译期可知的方法参数、局部基本类型变量和对象引用，用于按索引快速访问方法数据，并作为字节码指令的读写目标
- **操作数栈**：存放方法执行过程中产生的临时数据与中间结果，用于字节码通过 LIFO 完成运算操作数的传递和返回值处理
- **动态链接**：存放指向当前方法所属类的运行时常量池的指针，用于在运行时找到符号引用并解析为直接引用，从而快速定位调用目标
- **方法返回地址**：存放当前方法的调用方在字节码中的返回位置，用于在当前方法执行完后能够返回调用点继续执行

本地方法栈和虚拟机栈发挥的结构和作用类似，只不过虚拟机栈是为虚拟机执行 Java 方法，而本地方法栈是为虚拟机执行 Native 方法

<img src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/Java/202509162340065.png" alt="image-20250916234039981" style="zoom:50%;" />

#### 程序计数器

程序计数器（Program Counter Register）记录了线程当前执行字节码的地址，也可以记录下一行字节码的地址

- 每个线程都有自己的程序计数器
- 解释器根据程序计数器来读取并执行下一步操作
- 解释器也可以调整程序计数器来实现控制代码流程
- 当线程切换时，程序计数器保留了线程执行位置，以便切换回来后恢复执行

#### StackOverflowError

如果出现了无限递归，也就是一个方法会被无限次调用，这时候栈帧的深度会超过虚拟机栈允许的最大深度，则抛出 StackOverflowError 栈溢出错误

### 堆 Heap

#### 内存布局

这里的堆内存跟算法中的堆结构概念不一致，这里叫堆就是因为内存像一堆物品一样，需要的时候就拿走，不需要的时候就放回

在 JVM 中，**堆存放所有对象实例和数组，被所有线程共享**，线程通过对象引用来访问堆上的实例数据，同时堆也是垃圾回收器的主要作用对象

<img src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/Java/202509171145360.png" alt="image-20250917114525262" style="zoom:50%;" />

#### 新生代

新生代存放刚刚创建的对象，其中又被细分为三部分

- Eden：“伊甸园”是亚当和夏娃创造人类的地方，即 **JVM 创建对象的地方**，大部分对象第一次都会被分配到这里
- Survivor：当 Eden 空间即将用尽的时候，JVM 会执行一次 Minor GC 清理 Eden 和 Survivor-From，没有被垃圾回收的“幸存者”将会被复制到 Survivor-To，然后 JVM 会**把 To 与 From 互换角色，从而保证每一次都有一个空的 Survivor-To 来接收幸存者**，因此S0/S1实际上没有任何区别，只不过在逻辑上交替作为 From 和 To

#### 老生代

新老的差别就在于年龄，而 JVM 的 GC 会为每个对象维护一个年龄信息叫做 **GC 分代年龄，本质上是对象在 Survivor 中的存活次数，每次对象在一次 Minor GC 中从 Eden 或 From 复制到 To，其年龄 +1**

- JVM 会保存一个 **MaxTenuringThreshold**，如果对象的年龄超过这个阈值，那么就会从新生代晋升到老生代，而这个阈值会随着 Survivor 的空间占用和晋升速率来动态调整
- 当老年代空间不足时，会触发 Full GC，清理不再需要的对象，代价会远高于 Minor GC
- 年龄信息只有 4 位，也就是年龄值只能在 0-15

#### OutOfMemoryError

OutOfMemoryError 是 JVM 在内存耗尽时抛出的 Error，表示无法为所需内存或资源完成分配

- JVM 花费太多时间执行 GC 但是只能回收很少的堆空间
- 一次性申请一个很大的对象，堆找不到足够的连续内存来分配
- 最大堆内存 -Xmx 配置过小，无法满足峰值负载
- 短时间内创建大量临时对象，GC 来不及回收
- Survivor 空间不足或晋升阈值设置不当，导致大量对象提前晋升占满老年代

### 元空间 Metaspace

#### 内存布局

Metaspace 是存放类元数据的堆外内存区域

- 类元信息（介绍书）：类名、父类、接口、访问标志、字段表、方法表、方法分派表等
- 方法元信息（说明书）：字节码属性、注解、异常声明、调试信息等
- 运行时常量池（符号表）：编译期常量、符号引用、解析缓存等

<img src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/Java/202509171640862.png" alt="image-20250917164051759" style="zoom:50%;" />

#### 永久代和元空间

JDK 1.7 利用了堆的永久代来存储类的元数据，而 JDK 1.8 转移到了元空间之中，原因在于：

- 永久代需要通过 -XX:PermSize 和 -XX:MaxPermSize 指定大小，无法动态进行扩容，不灵活
- 元数据如果放在堆中，在动态生成大量类时，很容易产生 OOM 异常
- 永久代仍然受 GC 管理，会给整体带来不必要的复杂度，回收效率很低
- 为了统一 HotSpot VM 与 JRockit VM 所做的一种妥协

### 直接内存

这部分内存是 Java 程序**直接向操作系统申请的本地内存**，并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域

- **NIO（Non-Blocking I/O）**：通过 ByteBuffer.allocateDirect() 分配的堆外内存，通过 DirectByteBuffer 对象引用和操作堆外内存，常用于高性能 I/O，减少一次堆到缓冲区的复制
- **JNI（Java Native Interface）**：本地方法可以直接通过 JNI 调用 C/C++ 代码申请和使用堆外内存

### 对象内存

在 HotSpot 虚拟机中，一个对象在堆由三部分组成

- **对象头（Header）**：存储对象的元信息
    - **标记字段（Mark Word）**：存储对象运行时数据，如哈希码、GC 分代年龄、锁状态标识、锁指针等，会随着程序进行而动态改变
    - **类型指针（Class Pointer）**：指向在元空间中当前对象对应的类元信息，使得虚拟机可以确定对象的类
- **实例数据（Instance Data）**：存储对象的有效信息，即在程序中所定义的各种类型的字段内容
- **对齐填充（Padding）**：HotSpot 要求对象大小必须是 8 字节的整数倍，因此可能需要一部分空闲区域来对齐

<img src="https://dasi-blog.oss-cn-guangzhou.aliyuncs.com/Java/202509171802873.png" alt="image-20250917180240778" style="zoom:50%;" />

### 对象创建全过程

#### 1. 类加载检查

虚拟机遇到一条 new 指令时，JVM 首先检查运行时常量池中是否有该类的符号引用，如果没有，则会通过类加载器将 .class 文件加载到元空间中，并创建对应的 Class 对象放在堆中

#### 2. 内存分配

虚拟机会在堆上为对象分配内存，所需的内存大小在类加载完成便可以确定

- **指针碰撞（适用于堆内存规整）**：用过的内存全部整合到一边，没有用过的内存放在另一边，边界用一个分界指针存储，虚拟机只需要将分界指针向着没用过的内存方向移动对象大小即可
- **空闲列表（适用于堆有碎片）**：虚拟机会维护一个列表，其中记录了内存块的起始位置和可用大小，只需要找一块足够大的内存块分配给对象即可

> 取决于 GC 的实现方式，本质上取决于 GC 算法是“清除”还是“整理”

内存分配存在一个问题，即多个线程都在请求创建对象，此时需要确保并发安全

- **CAS（Compare And Swap）**：一种乐观锁的实现方式，在分配内存前会比较分界指针是否等于预期值，如果不相等则会重新尝试分配内存，直到成功为止
- **TLAB（Thread Local Allocation Buffer）**：虚拟机先为每个线程在堆中分配一小块私有的 Eden 区，又称为 TLAB，线程优先在各自的 TLAB 中分配内存给对象，如果 TLAB 不足，再退回到公共 Eden 区使用 CAS

#### 3. 初始化零值

分配完内存之后，虚拟机会先将内存空间清零，然后在对象头写入对象的元数据





















